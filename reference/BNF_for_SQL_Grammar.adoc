
= BNF for SQL Grammar

* <<BNF for SQL Grammar ::=, BNF for SQL Grammar>> 
** <<callable statement ::=, callable statement>>
** <<ddl statement ::=, ddl statement>>
** <<procedure body definition ::=, procedure body definition>>
** <<directly executable statement ::=, directly executable statement>>
* <<Reserved Keywords, Reserved Keywords>>
* <<Non-Reserved Keywords, Non-Reserved Keywords>>
* <<Reserved Keywords For Future Use, Reserved Keywords For Future Use>>
* <<Tokens, Tokens>>
* <<Production Cross-Reference, Production Cross-Reference>>
* <<Productions, Productions>>

== Reserved Keywords

|===
|Keyword |Usage

|_ADD_
|<<add set option ::=, add set option>>

|_ALL_
|<<standard aggregate function ::=, standard aggregate function>>, <<function ::=, function>>, <<query expression body ::=, query expression body>>, <<query term ::=, query term>>, <<select clause ::=, select clause>>, <<quantified comparison predicate ::=, quantified comparison predicate>>

|_ALTER_
|<<alter ::=, alter>>, <<alter column options ::=, alter column options>>, <<alter options ::=, alter options>>

|_AND_
|<<between predicate ::=, between predicate>>, <<between term ::=, between term>>

|_ANY_
|<<standard aggregate function ::=, standard aggregate function>>, <<quantified comparison predicate ::=, quantified comparison predicate>>

|_ARRAY_AGG_
|<<ordered aggreate function ::=, ordered aggreate function>>

|_AS_
|<<alter ::=, alter>>, <<array table ::=, array table>>, <<create procedure ::=, create procedure>>, <<option namespace ::=, option namespace>>, <<create table ::=, create table>>, <<create trigger ::=, create trigger>>, <<derived column ::=, derived column>>, <<dynamic data statement ::=, dynamic data statement>>, <<function ::=, function>>, <<loop statement ::=, loop statement>>, <<xml namespace element ::=, xml namespace element>>, <<object table ::=, object table>>, <<select derived column ::=, select derived column>>, <<table subquery ::=, table subquery>>, <<text table ::=, text table>>, <<table name ::=, table name>>, <<unescapedFunction ::=, unescapedFunction>>, <<with list element ::=, with list element>>, <<xml serialize ::=, xml serialize>>, <<xml table ::=, xml table>>

|_ASC_
|<<sort specification ::=, sort specification>>

|_ATOMIC_
|<<compound statement ::=, compound statement>>, <<for each row trigger action ::=, for each row trigger action>>

|_BEGIN_
|<<compound statement ::=, compound statement>>, <<for each row trigger action ::=, for each row trigger action>>

|_BETWEEN_
|<<between predicate ::=, between predicate>>

|_BIGDECIMAL_
|<<simple data type ::=, simple data type>>

|_BIGINT_
|<<simple data type ::=, simple data type>>

|_BIGINTEGER_
|<<simple data type ::=, simple data type>>

|_BLOB_
|<<simple data type ::=, simple data type>>, <<xml serialize ::=, xml serialize>>

|_BOOLEAN_
|<<simple data type ::=, simple data type>>

|_BOTH_
|<<function ::=, function>>

|_BREAK_
|<<branching statement ::=, branching statement>>

|_BY_
|<<group by clause ::=, group by clause>>, <<order by clause ::=, order by clause>>, <<window specification ::=, window specification>>

|_BYTE_
|<<simple data type ::=, simple data type>>

|_CALL_
|<<callable statement ::=, callable statement>>, <<call statement ::=, call statement>>

|_CASE_
|l<<case expression ::=, case expression>>, <<searched case expression ::=, searched case expression>>

|_CAST_
|<<function ::=, function>>

|_CHAR_
|<<function ::=, function>>, <<simple data type ::=, simple data type>>

|_CLOB_
|<<simple data type ::=, simple data type>>, <<xml serialize ::=, xml serialize>>

|_COLUMN_
|<<alter column options ::=, alter column options>>

|_COMMIT_
|<<create temporary table ::=, create temporary table>>

|_CONSTRAINT_
|<<create table body ::=, create table body>>

|_CONTINUE_
|<<branching statement ::=, branching statement>>

|_CONVERT_
|<<function ::=, function>>

|_CREATE_
|<<create procedure ::=, create procedure>>, <<create foreign temp table ::=, create foreign temp table>>, <<create table ::=, create table>>, <<create temporary table ::=, create temporary table>>, <<create trigger ::=, create trigger>>, <<procedure body definition ::=, procedure body definition>>

|_CROSS_
|<<cross join ::=, cross join>>

|_DATE_
|<<non numeric literal ::=, non numeric literal>>, <<simple data type ::=, simple data type>>

|_DAY_
|<<function ::=, function>>

|_DECIMAL_
|<<simple data type ::=, simple data type>>

|_DECLARE_
|<<declare statement ::=, declare statement>>

|_DEFAULT_
|<<table element ::=, table element>>, <<xml namespace element ::=, xml namespace element>>, <<object table column ::=, object table column>>, <<procedure parameter ::=, procedure parameter>>, <<xml table column ::=, xml table column>>

|_DELETE_
|<<alter ::=, alter>>, <<create trigger ::=, create trigger>>, <<delete statement ::=, delete statement>>

|_DESC_
|<<sort specification ::=, sort specification>>

|_DISTINCT_
|<<standard aggregate function ::=, standard aggregate function>>, <<function ::=, function>>, <<if statement ::=, if statement>>, <<query expression body ::=, query expression body>>， <<query term ::=, query term>>, <<select clause ::=, select clause>>

|_DOUBLE_
|<<simple data type ::=, simple data type>>

|_DROP_
|<<drop option ::=, drop option>>, <<drop table ::=, drop table>>

|_EACH_
|<<for each row trigger action ::=, for each row trigger action>>

|_ELSE_
|l<<case expression ::=, case expression>>, <<if statement ::=, if statement>>, <<searched case expression ::=, searched case expression>>

|_END_
|l<<case expression ::=, case expression>>, <<compound statement ::=, compound statement>>, <<for each row trigger action ::=, for each row trigger action>>, <<searched case expression ::=, searched case expression>>

|_ERROR_
|<<raise error statement ::=, raise error statement>>

|_ESCAPE_
|<<match predicate ::=, match predicate>>, <<text table ::=, text table>>

|_EXCEPT_
|<<query expression body ::=, query expression body>>

|_EXEC_
|<<dynamic data statement ::=, dynamic data statement>>, <<call statement ::=, call statement>>

|_EXECUTE_
|<<dynamic data statement ::=, dynamic data statement>>, <<call statement ::=, call statement>>

|_EXISTS_
|<<exists predicate ::=, exists predicate>>

|_FALSE_
|<<non numeric literal ::=, non numeric literal>>

|_FETCH_
|<<fetch clause ::=, fetch clause>>

|_FILTER_
|<<filter clause ::=, filter clause>>

|_FLOAT_
|<<simple data type ::=, simple data type>>

|_FOR_
|<<for each row trigger action ::=, for each row trigger action>>, <<function ::=, function>>, <<text aggreate function ::=, text aggreate function>>, <<text table column ::=, text table column>>, <<xml table column ::=, xml table column>>

|_FOREIGN_
|<<alter options ::=, alter options>>, <<create procedure ::=, create procedure>>, <<create foreign temp table ::=, create foreign temp table>>, <<create table ::=, create table>>, <<foreign key ::=, foreign key>>

|_FROM_
|<<delete statement ::=, delete statement>>, <<from clause ::=, from clause>>, <<function ::=, function>>, <<if statement ::=, if statement>>

|_FULL_
|<<qualified table ::=, qualified table>>

|_FUNCTION_
|<<create procedure ::=, create procedure>>

|_GEOMETRY_
|<<simple data type ::=, simple data type>>

|_GLOBAL_
|<<create table ::=, create table>>

|_GROUP_
|<<group by clause ::=, group by clause>>

|_HAVING_
|<<having clause ::=, having clause>>

|_HOUR_
|<<function ::=, function>>

|_IF_
|<<if statement ::=, if statement>>

|_IMMEDIATE_
|<<dynamic data statement ::=, dynamic data statement>>

|_IN_
|<<procedure parameter ::=, procedure parameter>>, <<in predicate ::=, in predicate>>

|_INNER_
|<<qualified table ::=, qualified table>>

|_INOUT_
|<<procedure parameter ::=, procedure parameter>>

|_INSERT_
|<<alter ::=, alter>>, <<create trigger ::=, create trigger>>, <<function ::=, function>>, <<insert statement ::=, insert statement>>

|_INTEGER_
|<<simple data type ::=, simple data type>>

|_INTERSECT_
|<<query term ::=, query term>>

|_INTO_
|<<dynamic data statement ::=, dynamic data statement>>, <<insert statement ::=, insert statement>>, <<into clause ::=, into clause>>

|_IS_
|<<if statement ::=, if statement>>, <<is null predicate ::=, is null predicate>>

|_JOIN_
|<<cross join ::=, cross join>>, <<make dep options ::=, make dep options>>, <<qualified table ::=, qualified table>>

|_LANGUAGE_
|<<object table ::=, object table>>

|_LATERAL_
|<<table subquery ::=, table subquery>>

|_LEADING_
|<<function ::=, function>>

|_LEAVE_
|<<branching statement ::=, branching statement>>

|_LEFT_
|<<function ::=, function>>, <<qualified table ::=, qualified table>>

|_LIKE_
|<<match predicate ::=, match predicate>>

|_LIKE_REGEX_
|<<like regex predicate ::=, like regex predicate>>

|_LIMIT_
|<<limit clause ::=, limit clause>>

|_LOCAL_
|<<create foreign temp table ::=, create foreign temp table>>, <<create temporary table ::=, create temporary table>>

|_LONG_
|<<simple data type ::=, simple data type>>

|_LOOP_
|<<loop statement ::=, loop statement>>

|_MAKEDEP_
|<<option clause ::=, option clause>>, <<table primary ::=, table primary>>

|_MAKEIND_
|<<option clause ::=, option clause>>, <<table primary ::=, table primary>>

|_MAKENOTDEP_
|<<option clause ::=, option clause>>, <<table primary ::=, table primary>>

|_MERGE_
|<<insert statement ::=, insert statement>>

|_MINUTE_
|<<function ::=, function>>

|_MONTH_
|<<function ::=, function>>

|_NO_
|<<make dep options ::=, make dep options>>, <<xml namespace element ::=, xml namespace element>>, <<text table column ::=, text table column>>, <<text table ::=, text table>>

|_NOCACHE_
|<<option clause ::=, option clause>>

|_NOT_
|<<between predicate ::=, between predicate>>, <<compound statement ::=, compound statement>>, <<table element ::=, table element>>, <<if statement ::=, if statement>>, <<is null predicate ::=, is null predicate>>, <<match predicate ::=, match predicate>>, <<boolean factor ::=, boolean factor>>, <<procedure parameter ::=, procedure parameter>>, <<procedure result column ::=, procedure result column>>, <<like regex predicate ::=, like regex predicate>>, <<in predicate ::=, in predicate>>, <<temporary table element ::=, temporary table element>>

|_NULL_
|<<table element ::=, table element>>, <<is null predicate ::=, is null predicate>>, <<non numeric literal ::=, non numeric literal>>, <<procedure parameter ::=, procedure parameter>>, <<procedure result column ::=, procedure result column>>, <<temporary table element ::=, temporary table element>>, <<xml query ::=, xml query>>

|_OBJECT_
|<<simple data type ::=, simple data type>>

|_OF_
|<<alter ::=, alter>>, <<create trigger ::=, create trigger>>

|_OFFSET_

|<<limit clause ::=, limit clause>>

|_ON_
|<<alter ::=, alter>>, <<create foreign temp table ::=, create foreign temp table>>, <<create temporary table ::=, create temporary table>>, <<create trigger ::=, create trigger>>, <<loop statement ::=, loop statement>>, <<qualified table ::=, qualified table>>, <<xml query ::=, xml query>>

|_ONLY_
|<<fetch clause ::=, fetch clause>>

|_OPTION_
|<<option clause ::=, option clause>>

|_OPTIONS_
|<<alter options list ::=, alter options list>>, <<options clause ::=, options clause>>

|_OR_
|<<boolean value expression ::=, boolean value expression>>

|_ORDER_
|<<order by clause ::=, order by clause>>

|_OUT_
|<<procedure parameter ::=, procedure parameter>>

|_OUTER_
|<<qualified table ::=, qualified table>>

|_OVER_
|<<window specification ::=, window specification>>

|_PARAMETER_
|<<alter column options ::=, alter column options>>

|_PARTITION_
|<<window specification ::=, window specification>>

|_PRIMARY_
|<<table element ::=, table element>>, <<create temporary table ::=, create temporary table>>, <<primary key ::=, primary key>>

|_PROCEDURE_
|<<alter ::=, alter>>, <<alter options ::=, alter options>>, <<create procedure ::=, create procedure>>, <<procedure body definition ::=, procedure body definition>>

|_REAL_
|<<simple data type ::=, simple data type>>

|_REFERENCES_
|<<foreign key ::=, foreign key>>

|_RETURN_
|<<assignment statement ::=, assignment statement>>, <<return statement ::=, return statement>>, <<data statement ::=, data statement>>

|_RETURNS_
|<<create procedure ::=, create procedure>>

|_RIGHT_
|<<function ::=, function>>, <<qualified table ::=, qualified table>>

|_ROLLUP_
|<<group by clause ::=, group by clause>>

|_ROW_
|<<fetch clause ::=, fetch clause>>, <<for each row trigger action ::=, for each row trigger action>>, <<limit clause ::=, limit clause>>, <<text table ::=, text table>>

|_ROWS_
|<<create temporary table ::=, create temporary table>>, <<fetch clause ::=, fetch clause>>, <<limit clause ::=, limit clause>>

|_SECOND_
|<<function ::=, function>>

|_SELECT_
|<<select clause ::=, select clause>>

|_SET_
|<<add set option ::=, add set option>>, <<option namespace ::=, option namespace>>, <<update statement ::=, update statement>>

|_SHORT_
|<<simple data type ::=, simple data type>>

|_SIMILAR_
|<<match predicate ::=, match predicate>>

|_SMALLINT_
|<<simple data type ::=, simple data type>>

|_SOME_
|<<standard aggregate function ::=, standard aggregate function>>, <<quantified comparison predicate ::=, quantified comparison predicate>>

|_SQLEXCEPTION_
|<<sql exception ::=, sql exception>>

|_SQLSTATE_
|<<sql exception ::=, sql exception>>

|_SQLWARNING_
|<<raise statement ::=, raise statement>>

|_STRING_
|<<dynamic data statement ::=, dynamic data statement>>, <<simple data type ::=, simple data type>>, <<xml serialize ::=, xml serialize>>

|_TABLE_
|<<alter options ::=, alter options>>, <<create procedure ::=, create procedure>>, <<create foreign temp table ::=, create foreign temp table>>, <<create table ::=, create table>>, <<create temporary table ::=, create temporary table>>, <<drop table ::=, drop table>>, <<query primary ::=, query primary>>, <<table subquery ::=, table subquery>>

|_TEMPORARY_
|<<create foreign temp table ::=, create foreign temp table>>, <<create table ::=, create table>>, <<create temporary table ::=, create temporary table>>

|_THEN_
|l<<case expression ::=, case expression>>, <<searched case expression ::=, searched case expression>>

|_TIME_
|<<non numeric literal ::=, non numeric literal>>, <<simple data type ::=, simple data type>>

|_TIMESTAMP_
|<<non numeric literal ::=, non numeric literal>>, <<simple data type ::=, simple data type>>

|_TINYINT_
|<<simple data type ::=, simple data type>>

|_TO_
|<<match predicate ::=, match predicate>>

|_TRAILING_
|<<function ::=, function>>

|_TRANSLATE_
|<<function ::=, function>>

|_TRIGGER_
|<<alter ::=, alter>>, <<create trigger ::=, create trigger>>

|_TRUE_
|<<non numeric literal ::=, non numeric literal>>

|_UNION_
|<<cross join ::=, cross join>>, <<query expression body ::=, query expression body>>

|_UNIQUE_
|<<other constraints ::=, other constraints>>, <<table element ::=, table element>>

|_UNKNOWN_
|<<non numeric literal ::=, non numeric literal>>

|_UPDATE_
|<<alter ::=, alter>>, <<create trigger ::=, create trigger>>, <<dynamic data statement ::=, dynamic data statement>>, <<update statement ::=, update statement>>

|_USER_
|<<function ::=, function>>

|_USING_
|<<dynamic data statement ::=, dynamic data statement>>

|_VALUES_
|<<query primary ::=, query primary>>

|_VARBINARY_
|<<simple data type ::=, simple data type>>, <<xml serialize ::=, xml serialize>>

|_VARCHAR_
|<<simple data type ::=, simple data type>>, <<xml serialize ::=, xml serialize>>

|_VIRTUAL_
|<<alter options ::=, alter options>>, <<create procedure ::=, create procedure>>, <<create table ::=, create table>>, <<procedure body definition ::=, procedure body definition>>

|_WHEN_
|l<<case expression ::=, case expression>>, <<searched case expression ::=, searched case expression>>

|_WHERE_
|<<filter clause ::=, filter clause>>, <<where clause ::=, where clause>>

|_WHILE_
|<<while statement ::=, while statement>>

|_WITH_
|<<assignment statement ::=, assignment statement>>, <<query expression ::=, query expression>>, <<data statement ::=, data statement>>

|_WITHOUT_
|<<assignment statement ::=, assignment statement>>, <<data statement ::=, data statement>>

|_XML_
|<<simple data type ::=, simple data type>>

|_XMLAGG_
|<<ordered aggreate function ::=, ordered aggreate function>>

|_XMLATTRIBUTES_
|<<xml attributes ::=, xml attributes>>

|_XMLCAST_
|<<unescapedFunction ::=, unescapedFunction>>

|_XMLCOMMENT_
|<<function ::=, function>>

|_XMLCONCAT_
|<<function ::=, function>>

|_XMLELEMENT_
|<<xml element ::=, xml element>>

|_XMLEXISTS_
|<<xml query ::=, xml query>>

|_XMLFOREST_
|<<xml forest ::=, xml forest>>

|_XMLNAMESPACES_
|<<xml namespaces ::=, xml namespaces>>

|_XMLPARSE_
|<<xml parse ::=, xml parse>>

|_XMLPI_
|<<function ::=, function>>

|_XMLQUERY_
|<<xml query ::=, xml query>>

|_XMLSERIALIZE_
|<<xml serialize ::=, xml serialize>>

|_XMLTABLE_
|<<xml table ::=, xml table>>

|_XMLTEXT_
|<<function ::=, function>>

|_YEAR_
|<<function ::=, function>>
|===

== Non-Reserved Keywords

|===
|Keyword |Usage

|_ACCESSPATTERN_
|<<other constraints ::=, other constraints>>, <<non-reserved identifier ::=, non-reserved identifier>>

|_ARRAYTABLE_
|<<array table ::=, array table>>, <<non-reserved identifier ::=, non-reserved identifier>>

|_AUTO_INCREMENT_
|<<table element ::=, table element>>, <<non-reserved identifier ::=, non-reserved identifier>>

|_AVG_
|<<standard aggregate function ::=, standard aggregate function>>, <<non-reserved identifier ::=, non-reserved identifier>>

|_CHAIN_
|<<sql exception ::=, sql exception>>, <<non-reserved identifier ::=, non-reserved identifier>>

|_COLUMNS_
|<<array table ::=, array table>>, <<non-reserved identifier ::=, non-reserved identifier>>, <<object table ::=, object table>>, <<text table ::=, text table>> + <<xml table ::=, xml table>>

|_CONTENT_
|<<non-reserved identifier ::=, non-reserved identifier>>, <<xml parse ::=, xml parse>>, <<xml serialize ::=, xml serialize>>

|_COUNT_
|<<standard aggregate function ::=, standard aggregate function>>, <<non-reserved identifier ::=, non-reserved identifier>>

|_DELIMITER_
|<<non-reserved identifier ::=, non-reserved identifier>>, <<text aggreate function ::=, text aggreate function>>, <<text table ::=, text table>>

|_DENSE_RANK_
|<<analytic aggregate function ::=, analytic aggregate function>>, <<non-reserved identifier ::=, non-reserved identifier>>

|_DISABLED_
|<<alter ::=, alter>>, <<non-reserved identifier ::=, non-reserved identifier>>

|_DOCUMENT_
|<<non-reserved identifier ::=, non-reserved identifier>>, <<xml parse ::=, xml parse>>, <<xml serialize ::=, xml serialize>>

|_EMPTY_
|<<non-reserved identifier ::=, non-reserved identifier>>, <<xml query ::=, xml query>>

|_ENABLED_
|<<alter ::=, alter>>, <<non-reserved identifier ::=, non-reserved identifier>>

|_ENCODING_
|<<non-reserved identifier ::=, non-reserved identifier>>, <<text aggreate function ::=, text aggreate function>>, <<xml serialize ::=, xml serialize>>

|_EVERY_
|<<standard aggregate function ::=, standard aggregate function>>, <<non-reserved identifier ::=, non-reserved identifier>>

|_EXCEPTION_
|<<compound statement ::=, compound statement>>, <<declare statement ::=, declare statement>>, <<non-reserved identifier ::=, non-reserved identifier>>

|_EXCLUDING_
|<<non-reserved identifier ::=, non-reserved identifier>>, <<xml serialize ::=, xml serialize>>

|_EXTRACT_
|<<function ::=, function>>, <<non-reserved identifier ::=, non-reserved identifier>>

|_FIRST_
|<<fetch clause ::=, fetch clause>>, <<non-reserved identifier ::=, non-reserved identifier>>, <<sort specification ::=, sort specification>>

|_HEADER_
|<<non-reserved identifier ::=, non-reserved identifier>>, <<text aggreate function ::=, text aggreate function>>, <<texttable column ::=, texttable column>>, <<text table ::=, text table>>

|_INCLUDING_
|<<non-reserved identifier ::=, non-reserved identifier>>, <<xml serialize ::=, xml serialize>>

|_INDEX_
|<<other constraints ::=, other constraints>>, <<table element ::=, table element>>, <<non-reserved identifier ::=, non-reserved identifier>>

|_INSTEAD_
|<<alter ::=, alter>>, <<create trigger ::=, create trigger>>, <<non-reserved identifier ::=, non-reserved identifier>>

|_JSONARRAY_AGG_
|<<non-reserved identifier ::=, non-reserved identifier>>, <<ordered aggreate function ::=, ordered aggreate function>>

|_JSONOBJECT_
|<<json object ::=, json object>>, <<non-reserved identifier ::=, non-reserved identifier>>

|_KEY_
|<<table element ::=, table element>>, <<create temporary table ::=, create temporary table>>, <<foreign key ::=, foreign key>>, <<non-reserved identifier ::=, non-reserved identifier>>, <<primary key ::=, primary key>>

|_LAST_
|<<non-reserved identifier ::=, non-reserved identifier>>, <<sort specification ::=, sort specification>>

|_MAX_
|<<standard aggregate function ::=, standard aggregate function>>, <<make dep options ::=, make dep options>>, <<non-reserved identifier ::=, non-reserved identifier>>

|_MIN_
|<<standard aggregate function ::=, standard aggregate function>>, <<non-reserved identifier ::=, non-reserved identifier>>

|_NAME_
|<<function ::=, function>>, <<non-reserved identifier ::=, non-reserved identifier>>, <<xml element ::=, xml element>>

|_NAMESPACE_
|<<option namespace ::=, option namespace>>, <<non-reserved identifier ::=, non-reserved identifier>>

|_NEXT_
|<<fetch clause ::=, fetch clause>>, <<non-reserved identifier ::=, non-reserved identifier>>

|_NULLS_
|<<non-reserved identifier ::=, non-reserved identifier>>, <<sort specification ::=, sort specification>>

|_OBJECTTABLE_
|<<non-reserved identifier ::=, non-reserved identifier>>, <<object table ::=, object table>>

|_ORDINALITY_
|<<non-reserved identifier ::=, non-reserved identifier>>, <<text table column ::=, text table column>>, <<xml table column ::=, xml table column>>

|_PASSING_
|<<non-reserved identifier ::=, non-reserved identifier>>, <<object table ::=, object table>>, <<xml query ::=, xml query>>, <<xml query ::=, xml query>>, <<xml table ::=, xml table>>

|_PATH_
|<<non-reserved identifier ::=, non-reserved identifier>>, <<xml table column ::=, xml table column>>

|_PRESERVE_
|<<create temporary table ::=, create temporary table>>, <<non-reserved identifier ::=, non-reserved identifier>>

|_QUERYSTRING_
|<<non-reserved identifier ::=, non-reserved identifier>>, <<querystring function ::=, querystring function>>

|_QUOTE_
|<<non-reserved identifier ::=, non-reserved identifier>>, <<text aggreate function ::=, text aggreate function>>, <<text table ::=, text table>>

|_RAISE_
|<<non-reserved identifier ::=, non-reserved identifier>>, <<raise statement ::=, raise statement>>

|_RANK_
|<<analytic aggregate function ::=, analytic aggregate function>>, <<non-reserved identifier ::=, non-reserved identifier>>

|_RESULT_
|<<non-reserved identifier ::=, non-reserved identifier>>, <<procedure parameter ::=, procedure parameter>>

|_ROW_NUMBER_
|<<analytic aggregate function ::=, analytic aggregate function>>, <<non-reserved identifier ::=, non-reserved identifier>>

|_SELECTOR_
|<<non-reserved identifier ::=, non-reserved identifier>>, <<text table column ::=, text table column>>, <<text table ::=, text table>>

|_SERIAL_
|<<table element ::=, table element>>, <<non-reserved identifier ::=, non-reserved identifier>>, <<temporary table element ::=, temporary table element>>

|_SKIP_
|<<non-reserved identifier ::=, non-reserved identifier>>, <<text table ::=, text table>>

|_SQL_TSI_DAY_
|<<time interval ::=, time interval>>, <<non-reserved identifier ::=, non-reserved identifier>>

|_SQL_TSI_FRAC_SECOND_
|<<time interval ::=, time interval>>, <<non-reserved identifier ::=, non-reserved identifier>>

|_SQL_TSI_HOUR_
|<<time interval ::=, time interval>>, <<non-reserved identifier ::=, non-reserved identifier>>

|_SQL_TSI_MINUTE_
|<<time interval ::=, time interval>>, <<non-reserved identifier ::=, non-reserved identifier>>

|_SQL_TSI_MONTH_
|<<time interval ::=, time interval>>, <<non-reserved identifier ::=, non-reserved identifier>>

|_SQL_TSI_QUARTER_
|<<time interval ::=, time interval>>, <<non-reserved identifier ::=, non-reserved identifier>>

|_SQL_TSI_SECOND_
|<<time interval ::=, time interval>>, <<non-reserved identifier ::=, non-reserved identifier>>

|_SQL_TSI_WEEK_
|<<time interval ::=, time interval>>, <<non-reserved identifier ::=, non-reserved identifier>>

|_SQL_TSI_YEAR_
|<<time interval ::=, time interval>>, <<non-reserved identifier ::=, non-reserved identifier>>

|_STDDEV_POP_
|<<standard aggregate function ::=, standard aggregate function>>, <<non-reserved identifier ::=, non-reserved identifier>>

|_STDDEV_SAMP_
|<<standard aggregate function ::=, standard aggregate function>>, <<non-reserved identifier ::=, non-reserved identifier>>

|_SUBSTRING_
|<<function ::=, function>>, <<non-reserved identifier ::=, non-reserved identifier>>

|_SUM_
|<<standard aggregate function ::=, standard aggregate function>>, <<non-reserved identifier ::=, non-reserved identifier>>

|_TEXTAGG_
|<<non-reserved identifier ::=, non-reserved identifier>>, <<text aggreate function ::=, text aggreate function>>

|_TEXTTABLE_
|<<non-reserved identifier ::=, non-reserved identifier>>, <<text table ::=, text table>>

|_TIMESTAMPADD_
|<<function ::=, function>>, <<non-reserved identifier ::=, non-reserved identifier>>

|_TIMESTAMPDIFF_
|<<function ::=, function>>, <<non-reserved identifier ::=, non-reserved identifier>>

|_TO_BYTES_
|<<function ::=, function>>, <<non-reserved identifier ::=, non-reserved identifier>>

|_TO_CHARS_
|<<function ::=, function>>, <<non-reserved identifier ::=, non-reserved identifier>>

|_TRIM_
|<<function ::=, function>>, <<non-reserved identifier ::=, non-reserved identifier>>, <<text table column ::=, text table column>>, <<text table ::=, text table>>

|_VARIADIC_
|<<non-reserved identifier ::=, non-reserved identifier>>, <<procedure parameter ::=, procedure parameter>>

|_VAR_POP_
|<<standard aggregate function ::=, standard aggregate function>>, <<non-reserved identifier ::=, non-reserved identifier>>

|_VAR_SAMP_
|<<standard aggregate function ::=, standard aggregate function>>, <<non-reserved identifier ::=, non-reserved identifier>>

|_VERSION_
|<<non-reserved identifier ::=, non-reserved identifier>>, <<xml serialize ::=, xml serialize>>

|_VIEW_
|<<alter ::=, alter>>, <<alter options ::=, alter options>>, <<create table ::=, create table>>, <<non-reserved identifier ::=, non-reserved identifier>>

|_WELLFORMED_
|<<non-reserved identifier ::=, non-reserved identifier>>, <<xml parse ::=, xml parse>>

|_WIDTH_
|<<non-reserved identifier ::=, non-reserved identifier>>, <<text table column ::=, text table column>>

|_XMLDECLARATION_
|<<non-reserved identifier ::=, non-reserved identifier>>, <<xml serialize ::=, xml serialize>>
|===

== Reserved Keywords For Future Use

ALLOCATE, ARE, ARRAY, ASENSITIVE, ASYMETRIC, AUTHORIZATION, BINARY, CALLED, CASCADED, CHARACTER 

CHECK, CLOSE, COLLATE, CONNECT, CORRESPONDING, CRITERIA, CURRENT_DATE, CURRENT_TIME, CURRENT_TIMESTAMP, CURRENT_USER

CURSOR, CYCLE, DATALINK, DEALLOCATE, DEC, DEREF, DESCRIBE, DETERMINISTIC, DISCONNECT, DLNEWCOPY

DLPREVIOUSCOPY, DLURLCOMPLETE, DLURLCOMPLETEONLY, DLURLCOMPLETEWRITE, DLURLPATH, DLURLPATHONLY, DLURLPATHWRITE, DLURLSCHEME, DLURLSERVER, DLVALUE

DYNAMIC, ELEMENT, EXTERNAL, FREE, GET, GRANT, HAS, HOLD, IDENTITY, IMPORT

INDICATOR, INPUT, INSENSITIVE, INT, INTERVAL, ISOLATION, LARGE, LOCALTIME, LOCALTIMESTAMP, MATCH

MEMBER, METHOD, MODIFIES, MODULE, MULTISET, NATIONAL, NATURAL, NCHAR, NCLOB, NEW

NONE, NUMERIC, OLD, OPEN, OUTPUT, OVERLAPS, PRECISION, PREPARE, RANGE, READS

RECURSIVE, REFERENCING, RELEASE, REVOKE, ROLLBACK, SAVEPOINT, SCROLL, SEARCH, SENSITIVE, SESSION_USER

SPECIFIC, SPECIFICTYPE, SQL, START, STATIC, SUBMULTILIST, SYMETRIC, SYSTEM, SYSTEM_USER, TIMEZONE_HOUR

TIMEZONE_MINUTE, TRANSLATION, TREAT, VALUE, VARYING, WHENEVER, WINDOW, WITHIN, XMLBINARY, XMLDOCUMENT

XMLITERATE, XMLVALIDATE

== Tokens

|===
|Name |Definition |Usage

|_all in group identifier_
|<identifier> <period> <star>
|<<all in group ::=, all in group>>

|_binary string literal_
|"X" \| "x" "\’" (<hexit> <hexit>)+ "\’"
|<<non numeric literal ::=, non numeric literal>>

|_colon_
|":"
|<<make dep options ::=, make dep options>>, <<statement ::=, statement>>

|_comma_
|","
|<<alter options list ::=, alter options list>>, <<column list ::=, column list>>, <<create procedure ::=, create procedure>>, <<typed element list ::=, typed element list>>, <<create table body ::=, create table body>>, <<create temporary table ::=, create temporary table>>, <<derived column list ::=, derived column list>>, <<sql exception ::=, sql exception>>, <<named parameter list ::=, named parameter list>>, <<expression list ::=, expression list>>, <<from clause ::=, from clause>>, <<function ::=, function>>, <<limit clause ::=, limit clause>>, <<nested expression ::=, nested expression>>, <<object table ::=, object table>>, <<option clause ::=, option clause>>, <<options clause ::=, options clause>>, <<order by clause ::=, order by clause>>, <<simple data type ::=, simple data type>>, <<query expression ::=, query expression>>, <<query primary ::=, query primary>>, <<querystring function ::=, querystring function>>, <<select clause ::=, select clause>>, <<set clause list ::=, set clause list>>, <<in predicate ::=, in predicate>>, <<text aggreate function ::=, text aggreate function>>, <<text table ::=, text table>>, <<xml attributes ::=, xml attributes>>, <<xml element ::=, xml element>>, <<xml query ::=, xml query>>, <<xml forest ::=, xml forest>>, <<xml namespaces ::=, xml namespaces>>, <<xml query ::=, xml query>>, <<xml table ::=, xml table>>

|_concat_op_
|"\|\|"
|<<common value expression ::=, common value expression>>

|_decimal numeric literal_
|(<digit>)* <period> <unsigned integer literal>
|<<unsigned numeric literal ::=, unsigned numeric literal>>

|_digit_
|["0"-"9"]
|

|_dollar_
|"$"
|<<parameter reference ::=, parameter reference>>

|_eq_
|"="
|<<assignment statement ::=, assignment statement>>, <<callable statement ::=, callable statement>>, <<declare statement ::=, declare statement>>, <<named parameter list ::=, named parameter list>>, <<comparison operator ::=, comparison operator>>, <<set clause list ::=, set clause list>>

|_escaped function_
|"\{" "fn"
|<<unsigned value expression primary ::=, unsigned value expression primary>>

|_escaped join_
|"\{" "oj"
|<<table reference ::=, table reference>>

|_escaped type_
|"\{" ("d" \| "t" \| "ts" \| "b")
|<<non numeric literal ::=, non numeric literal>>

|_approximate numeric literal_
|<digit> <period> <unsigned integer literal> ["e","E"] (<plus> <minus>)? <unsigned integer literal>
|<<unsigned numeric literal ::=, unsigned numeric literal>>

|_ge_
|">="
|<<comparison operator ::=, comparison operator>>

|_gt_
|">"
|<<named parameter list ::=, named parameter list>>, <<comparison operator ::=, comparison operator>>

|_hexit_
|["a"-"f","A"-"F"] \| <digit>
|

|_identifier_
|<quoted_id> (<period> <quoted_id>)*
|<<identifier ::=, identifier>>, <<unsigned value expression primary ::=, unsigned value expression primary>>

|_id_part_
|("@" "#"  <letter>) (<letter> "_"  <digit>)*
|

|_lbrace_
|"\{"
|<<callable statement ::=, callable statement>>, <<match predicate ::=, match predicate>>

|_le_
|"<="
|<<comparison operator ::=, comparison operator>>

|_letter_
|["a"-"z","A"-"Z"] ["\u0153"-"\ufffd"]
|

|_lparen_
|"("
|<<standard aggregate function ::=, standard aggregate function>>, <<alter options list ::=, alter options list>>, <<analytic aggregate function ::=, analytic aggregate function>>, <<array table ::=, array table>>, <<callable statement ::=, callable statement>>, <<column list ::=, column list>>, <<other constraints ::=, other constraints>>, <<create procedure ::=, create procedure>>, <<create table body ::=, create table body>>, <<create temporary table ::=, create temporary table>>, <<filter clause ::=, filter clause>>, <<function ::=, function>>, <<group by clause ::=, group by clause>>, <<if statement ::=, if statement>>, <<json object ::=, json object>>, <<loop statement ::=, loop statement>>, <<make dep options ::=, make dep options>>, <<nested expression ::=, nested expression>>, <<object table ::=, object table>>, <<options clause ::=, options clause>>, <<ordered aggreate function ::=, ordered aggreate function>>, <<simple data type ::=, simple data type>>, <<query primary ::=, query primary>>, <<querystring function ::=, querystring function>>, <<in predicate ::=, in predicate>>, <<call statement ::=, call statement>>, <<subquery ::=, subquery>>, <<table subquery ::=, table subquery>>, <<table primary ::=, table primary>>, <<text aggreate function ::=, text aggreate function>>, <<text table ::=, text table>>, <<unescapedFunction ::=, unescapedFunction>>, <<while statement ::=, while statement>>, <<window specification ::=, window specification>>, <<with list element ::=, with list element>>, <<xml attributes ::=, xml attributes>>, <<xml element ::=, xml element>>, <<xml query ::=, xml query>>, <<xml forest ::=, xml forest>>, <<xml namespaces ::=, xml namespaces>>, <<xml parse ::=, xml parse>>, <<xml query ::=, xml query>>, <<xml serialize ::=, xml serialize>>, <<xml table ::=, xml table>>

|_lsbrace_
|"["
|<<data type ::=, data type>>, <<value expression primary ::=, value expression primary>>

|_lt_
|"<"
|<<comparison operator ::=, comparison operator>>

|_minus_
|"-"
|<<plus or minus ::=, plus or minus>>

|_ne_
|"<>"
|<<comparison operator ::=, comparison operator>>

|_ne2_
|"!="
|<<comparison operator ::=, comparison operator>>

|_period_
|"."
|

|_plus_
|"+"
|<<plus or minus ::=, plus or minus>>

|_qmark_
|"?"
|<<callable statement ::=, callable statement>>, <<parameter reference ::=, parameter reference>>

|_quoted_id_
|<id_part> "\"" ("\"\""  ~["\""])+"\""
|

|_rbrace_
|"}"
|<<callable statement ::=, callable statement>>, <<match predicate ::=, match predicate>>, <<non numeric literal ::=, non numeric literal>>, <<table reference ::=, table reference>>, <<unsigned value expression primary ::=, unsigned value expression primary>>

|_rparen_
|")"
|<<standard aggregate function ::=, standard aggregate function>>, <<alter options list ::=, alter options list>>, <<analytic aggregate function ::=, analytic aggregate function>>, <<array table ::=, array table>>, <<callable statement ::=, callable statement>>, <<column list ::=, column list>>, <<other constraints ::=, other constraints>>, <<create procedure ::=, create procedure>>, <<create table body ::=, create table body>>, <<create temporary table ::=, create temporary table>>, <<filter clause ::=, filter clause>>, <<function ::=, function>> + <<group by clause ::=, group by clause>>, <<if statement ::=, if statement>>, <<json object ::=, json object>>, <<loop statement ::=, loop statement>> + <<make dep options ::=, make dep options>>, <<nested expression ::=, nested expression>>, <<object table ::=, object table>>, <<options clause ::=, options clause>>, <<ordered aggreate function ::=, ordered aggreate function>>, <<simple data type ::=, simple data type>>, <<query primary ::=, query primary>>, <<querystring function ::=, querystring function>>, <<in predicate ::=, in predicate>>, <<call statement ::=, call statement>>, <<subquery ::=, subquery>>, <<table subquery ::=, table subquery>>, <<table primary ::=, table primary>>, <<text aggreate function ::=, text aggreate function>>, <<text table ::=, text table>>, <<unescapedFunction ::=, unescapedFunction>>, <<while statement ::=, while statement>>, <<window specification ::=, window specification>>, <<with list element ::=, with list element>>, <<xml attributes ::=, xml attributes>>, <<xml element ::=, xml element>>, <<xml query ::=, xml query>>, <<xml forest ::=, xml forest>>, <<xml namespaces ::=, xml namespaces>>, <<xml parse ::=, xml parse>>, <<xml query ::=, xml query>>, <<xml serialize ::=, xml serialize>>, <<xml table ::=, xml table>>

|_rsbrace_
|"]"
|<<data type ::=, data type>>, <<value expression primary ::=, value expression primary>>

|_semicolon_
|";"
|<<ddl statement ::=, ddl statement>>, <<delimited statement ::=, delimited statement>>

|_slash_
|"/"
|<<star or slash ::=, star or slash>>

|_star_
|"*"
|<<standard aggregate function ::=, standard aggregate function>>, <<dynamic data statement ::=, dynamic data statement>>, <<select clause ::=, select clause>>, <<star or slash ::=, star or slash>>

|_string literal_
|("N"  "E")? "\’" ("\’\’"  ~["\’"])* "\’"
|<<string ::=, string>>

|_unsigned integer literal_
|(<digit>)+
|<<unsigned integer ::=, unsigned integer>>, <<unsigned numeric literal ::=, unsigned numeric literal>>
|===


== Production Cross-Reference

|===
|Name |Usage

|_<<add set option ::=, add set option>>_
|<<alter options list ::=, alter options list>>

|_<<standard aggregate function ::=, standard aggregate function>>_
|<<unescapedFunction ::=, unescapedFunction>>

|_<<all in group ::=, all in group>>_
|<<select sublist ::=, select sublist>>

|_<<alter ::=, alter>>_
|<<directly executable statement ::=, directly executable statement>>

|_<<alter column options ::=, alter column options>>_
|<<alter options ::=, alter options>>

|_<<alter options list ::=, alter options list>>_
|<<alter column options ::=, alter column options>>, <<alter options ::=, alter options>>

|_<<alter options ::=, alter options>>_
|<<ddl statement ::=, ddl statement>>

|_<<analytic aggregate function ::=, analytic aggregate function>>_
|<<unescapedFunction ::=, unescapedFunction>>

|_<<array table ::=, array table>>_
|<<table primary ::=, table primary>>

|_<<assignment statement ::=, assignment statement>>_
|<<delimited statement ::=, delimited statement>>

|_<<assignment statement operand ::=, assignment statement operand>>_
|<<assignment statement ::=, assignment statement>>, <<declare statement ::=, declare statement>>

|_<<between predicate ::=, between predicate>>_
|<<boolean primary ::=, boolean primary>>

|_<<boolean primary ::=, boolean primary>>_
|<<filter clause ::=, filter clause>>, <<boolean factor ::=, boolean factor>>

|_<<branching statement ::=, branching statement>>_
|<<delimited statement ::=, delimited statement>>

|_l<<case expression ::=, case expression>>_
|<<unsigned value expression primary ::=, unsigned value expression primary>>

|_<<character ::=, character>>_
|<<match predicate ::=, match predicate>>, <<text aggreate function ::=, text aggreate function>>, <<text table ::=, text table>>

|_<<column list ::=, column list>>_
|<<other constraints ::=, other constraints>>, <<create temporary table ::=, create temporary table>>, <<foreign key ::=, foreign key>>, <<insert statement ::=, insert statement>>, <<primary key ::=, primary key>>, <<with list element ::=, with list element>>

|_<<common value expression ::=, common value expression>>_
|<<between predicate ::=, between predicate>>, <<boolean primary ::=, boolean primary>>, <<comparison predicate ::=, comparison predicate>>, <<sql exception ::=, sql exception>>, <<match predicate ::=, match predicate>>, <<like regex predicate ::=, like regex predicate>>, <<in predicate ::=, in predicate>>, <<text table ::=, text table>>

|_<<comparison predicate ::=, comparison predicate>>_
|<<boolean primary ::=, boolean primary>>

|_<<between term ::=, between term>>_
|<<boolean value expression ::=, boolean value expression>>

|_<<boolean value expression ::=, boolean value expression>>_
|<<condition ::=, condition>>

|_<<compound statement ::=, compound statement>>_
|<<statement ::=, statement>>, <<directly executable statement ::=, directly executable statement>>

|_<<other constraints ::=, other constraints>>_
|<<create table body ::=, create table body>>

|_<<table element ::=, table element>>_
|<<create table body ::=, create table body>>

|_<<create procedure ::=, create procedure>>_
|<<ddl statement ::=, ddl statement>>

|_<<typed element list ::=, typed element list>>_
|<<array table ::=, array table>>, <<dynamic data statement ::=, dynamic data statement>>

|_<<create foreign temp table ::=, create foreign temp table>>_
|<<directly executable statement ::=, directly executable statement>>

|_<<option namespace ::=, option namespace>>_
|<<ddl statement ::=, ddl statement>>

|_<<create table ::=, create table>>_
|<<ddl statement ::=, ddl statement>>

|_<<create table body ::=, create table body>>_
|<<create foreign temp table ::=, create foreign temp table>>, <<create table ::=, create table>>

|_<<create temporary table ::=, create temporary table>>_
|<<directly executable statement ::=, directly executable statement>>

|_<<create trigger ::=, create trigger>>_
|<<ddl statement ::=, ddl statement>>, <<directly executable statement ::=, directly executable statement>>

|_<<condition ::=, condition>>_
|<<expression ::=, expression>>, <<having clause ::=, having clause>>, <<if statement ::=, if statement>>, <<qualified table ::=, qualified table>>, <<searched case expression ::=, searched case expression>>, <<where clause ::=, where clause>>, <<while statement ::=, while statement>>

|_<<cross join ::=, cross join>>_
|<<joined table ::=, joined table>>

|_<<declare statement ::=, declare statement>>_
|<<delimited statement ::=, delimited statement>>

|_<<delete statement ::=, delete statement>>_
|<<assignment statement operand ::=, assignment statement operand>>, <<directly executable statement ::=, directly executable statement>>

|_<<delimited statement ::=, delimited statement>>_
|<<statement ::=, statement>>

|_<<derived column ::=, derived column>>_
|<<derived column list ::=, derived column list>>, <<object table ::=, object table>>, <<querystring function ::=, querystring function>>, <<text aggreate function ::=, text aggreate function>>, <<xml attributes ::=, xml attributes>>, <<xml query ::=, xml query>>, <<xml query ::=, xml query>>, <<xml table ::=, xml table>>

|_<<derived column list ::=, derived column list>>_
|<<json object ::=, json object>>, <<xml forest ::=, xml forest>>

|_<<drop option ::=, drop option>>_
|<<alter options list ::=, alter options list>>

|_<<drop table ::=, drop table>>_
|<<directly executable statement ::=, directly executable statement>>

|_<<dynamic data statement ::=, dynamic data statement>>_
|<<data statement ::=, data statement>>

|_<<raise error statement ::=, raise error statement>>_
|<<delimited statement ::=, delimited statement>>

|_<<sql exception ::=, sql exception>>_
|<<assignment statement operand ::=, assignment statement operand>>, <<exception reference ::=, exception reference>>

|_<<exception reference ::=, exception reference>>_
|<<sql exception ::=, sql exception>>, <<raise statement ::=, raise statement>>

|_<<named parameter list ::=, named parameter list>>_
|<<callable statement ::=, callable statement>>, <<call statement ::=, call statement>>

|_<<exists predicate ::=, exists predicate>>_
|<<boolean primary ::=, boolean primary>>

|_<<expression ::=, expression>>_
|<<standard aggregate function ::=, standard aggregate function>>, <<assignment statemen operand ::=, assignment statemen operand>>, l<<case expression ::=, case expression>>, <<derived column ::=, derived column>>, <<dynamic data statement ::=, dynamic data statement>>, <<raise error statement ::=, raise error statement>>, <<named parameter list ::=, named parameter list>>, <<expression list ::=, expression list>>, <<function ::=, function>>, <<nested expression ::=, nested expression>>, <<object table column ::=, object table column>>, <<ordered aggreate function ::=, ordered aggreate function>>, <<querystring function ::=, querystring function>>, <<return statement ::=, return statement>>, <<searched case expression ::=, searched case expression>>, <<select derived column ::=, select derived column>>, <<set clause list ::=, set clause list>>, <<sort key ::=, sort key>>, <<unescapedFunction ::=, unescapedFunction>>, <<xml table column ::=, xml table column>>, <<xml element ::=, xml element>>, <<xml parse ::=, xml parse>>, <<xml serialize ::=, xml serialize>>

|_<<expression list ::=, expression list>>_
|<<callable statement ::=, callable statement>>, <<other constraints ::=, other constraints>>, <<function ::=, function>>, <<group by clause ::=, group by clause>>, <<query primary ::=, query primary>>, <<call statement ::=, call statement>>, <<window specification ::=, window specification>>

|_<<fetch clause ::=, fetch clause>>_
|<<limit clause ::=, limit clause>>

|_<<filter clause ::=, filter clause>>_
|<<function ::=, function>>, <<unescapedFunction ::=, unescapedFunction>>

|_<<for each row trigger action ::=, for each row trigger action>>_
|<<alter ::=, alter>>, <<create trigger ::=, create trigger>>

|_<<foreign key ::=, foreign key>>_
|<<create table body ::=, create table body>>

|_<<from clause ::=, from clause>>_
|<<query ::=, query>>

|_<<function ::=, function>>_
|<<unescapedFunction ::=, unescapedFunction>>, <<unsigned value expression primary ::=, unsigned value expression primary>>

|_<<group by clause ::=, group by clause>>_
|<<query ::=, query>>

|_<<having clause ::=, having clause>>_
|<<query ::=, query>>

|_<<identifier ::=, identifier>>_
|<<alter ::=, alter>>, <<alter column options ::=, alter column options>>, <<alter options ::=, alter options>>, <<array table ::=, array table>>, <<assignment statement ::=, assignment statement>>, <<branching statement ::=, branching statement>>, <<callable statement ::=, callable statement>>, <<column list ::=, column list>>, <<compound statement ::=, compound statement>>, <<table element ::=, table element>>, <<create procedure ::=, create procedure>>, <<typed element list ::=, typed element list>>, <<create foreign temp table ::=, create foreign temp table>>, <<option namespace ::=, option namespace>>, <<create table ::=, create table>>, <<create table body ::=, create table body>>, <<create temporary table ::=, create temporary table>>, <<create trigger ::=, create trigger>>, <<declare statement ::=, declare statement>>, <<delete statement ::=, delete statement>>, <<derived column ::=, derived column>>, <<drop option ::=, drop option>>, <<drop table ::=, drop table>>, <<dynamic data statement ::=, dynamic data statement>>, <<exception reference ::=, exception reference>>, <<named parameter list ::=, named parameter list>>, <<foreign key ::=, foreign key>>, <<function ::=, function>>, <<if statement ::=, if statement>>, <<insert statement ::=, insert statement>>, <<into clause ::=, into clause>>, <<loop statement ::=, loop statement>>, <<xml namespace element ::=, xml namespace element>>, <<object table column ::=, object table column>>, <<object table ::=, object table>>, <<option clause ::=, option clause>>, <<option pair ::=, option pair>>, <<procedure parameter ::=, procedure parameter>>, <<procedure result column ::=, procedure result column>>, <<query primary ::=, query primary>>, <<select derived column ::=, select derived column>>, <<set clause list ::=, set clause list>>, <<statement ::=, statement>>, <<call statement ::=, call statement>>, <<table subquery ::=, table subquery>>, <<temporary table element ::=, temporary table element>>, <<text aggreate function ::=, text aggreate function>>, <<text table column ::=, text table column>>, <<text table ::=, text table>>, <<table name ::=, table name>>, <<update statement ::=, update statement>>, <<with list element ::=, with list element>>, <<xml table column ::=, xml table column>>, <<xml element ::=, xml element>>, <<xml serialize ::=, xml serialize>>, <<xml table ::=, xml table>>

|_<<if statement ::=, if statement>>_
|<<statement ::=, statement>>

|_<<insert statement ::=, insert statement>>_
|<<assignment statement operand ::=, assignment statement operand>>, <<directly executable statement ::=, directly executable statement>>

|_<<integer parameter ::=, integer parameter>>_
|<<fetch clause ::=, fetch clause>>, <<limit clause ::=, limit clause>>

|_<<unsigned integer ::=, unsigned integer>>_
|<<dynamic data statement ::=, dynamic data statement>>, <<integer parameter ::=, integer parameter>>, <<make dep options ::=, make dep options>>, <<parameter reference ::=, parameter reference>>, <<simple data type ::=, simple data type>>, <<text table column ::=, text table column>>, <<text table ::=, text table>>

|_<<time interval ::=, time interval>>_
|<<function ::=, function>>

|_<<into clause ::=, into clause>>_
|<<query ::=, query>>

|_<<is null predicate ::=, is null predicate>>_
|<<boolean primary ::=, boolean primary>>

|_<<joined table ::=, joined table>>_
|<<table primary ::=, table primary>>, <<table reference ::=, table reference>>

|_<<json object ::=, json object>>_
|<<function ::=, function>>

|_<<limit clause ::=, limit clause>>_
|<<query expression body ::=, query expression body>>

|_<<loop statement ::=, loop statement>>_
|<<statement ::=, statement>>

|_<<make dep options ::=, make dep options>>_
|<<option clause ::=, option clause>>, <<table primary ::=, table primary>>

|_<<match predicate ::=, match predicate>>_
|<<boolean primary ::=, boolean primary>>

|_<<xml namespace element ::=, xml namespace element>>_
|<<xml namespaces ::=, xml namespaces>>

|_<<nested expression ::=, nested expression>>_
|<<unsigned value expression primary ::=, unsigned value expression primary>>

|_<<non numeric literal ::=, non numeric literal>>_
|<<option pair ::=, option pair>>, <<value expression primary ::=, value expression primary>>

|_<<non-reserved identifier ::=, non-reserved identifier>>_
|<<identifier ::=, identifier>>, <<unsigned value expression primary ::=, unsigned value expression primary>>

|_<<boolean factor ::=, boolean factor>>_
|<<boolean term ::=, boolean term>>

|_<<object table column ::=, object table column>>_
|<<object table ::=, object table>>

|_<<object table ::=, object table>>_
|<<table primary ::=, table primary>>

|_<<comparison operator ::=, comparison operator>>_
|<<comparison predicate ::=, comparison predicate>>, <<quantified comparison predicate ::=, quantified comparison predicate>>

|_<<option clause ::=, option clause>>_
|<<callable statement ::=, callable statement>>, <<delete statement ::=, delete statement>>, <<insert statement ::=, insert statement>>, <<query expression body ::=, query expression body>>, <<call statement ::=, call statement>>, <<update statement ::=, update statement>>

|_<<option pair ::=, option pair>>_
|<<add set option ::=, add set option>>, <<options clause ::=, options clause>>

|_<<options clause ::=, options clause>>_
|<<table element ::=, table element>>, <<create procedure ::=, create procedure>>, <<create table ::=, create table>>, <<create table body ::=, create table body>>, <<procedure parameter ::=, procedure parameter>>, <<procedure result column ::=, procedure result column>>

|_<<order by clause ::=, order by clause>>_
|<<function ::=, function>>, <<ordered aggreate function ::=, ordered aggreate function>>, <<query expression body ::=, query expression body>>, <<text aggreate function ::=, text aggreate function>>, <<window specification ::=, window specification>>

|_<<ordered aggreate function ::=, ordered aggreate function>>_
|<<unescapedFunction ::=, unescapedFunction>>

|_<<parameter reference ::=, parameter reference>>_
|<<unsigned value expression primary ::=, unsigned value expression primary>>

|_<<data type ::=, data type>>_
|<<table element ::=, table element>>, <<create procedure ::=, create procedure>>, <<typed element list ::=, typed element list>>, <<declare statement ::=, declare statement>>, <<function ::=, function>>, <<object table column ::=, object table column>>, <<procedure parameter ::=, procedure parameter>>, <<procedure result column ::=, procedure result column>>, <<temporary table element ::=, temporary table element>>, <<text table column ::=, text table column>>, <<unescapedFunction ::=, unescapedFunction>>, <<xml table column ::=, xml table column>>

|_<<simple data type ::=, simple data type>>_
|<<data type ::=, data type>>

|_<<numeric value expression ::=, numeric value expression>>_
|<<common value expression ::=, common value expression>>, <<value expression primary ::=, value expression primary>>

|_<<plus or minus ::=, plus or minus>>_
|<<option pair ::=, option pair>>, <<numeric value expression ::=, numeric value expression>>, <<value expression primary ::=, value expression primary>>

|_<<primary key ::=, primary key>>_
|<<create table body ::=, create table body>>

|_<<procedure parameter ::=, procedure parameter>>_
|<<create procedure ::=, create procedure>>

|_<<procedure result column ::=, procedure result column>>_
|<<create procedure ::=, create procedure>>

|_<<qualified table ::=, qualified table>>_
|<<joined table ::=, joined table>>

|_<<query ::=, query>>_
|<<query primary ::=, query primary>>

|_<<query expression ::=, query expression>>_
|<<alter ::=, alter>>, <<assignment statement operand ::=, assignment statement operand>>, <<create table ::=, create table>>, <<insert statement ::=, insert statement>>, <<loop statement ::=, loop statement>>, <<subquery ::=, subquery>>, <<table subquery ::=, table subquery>>, <<directly executable statement ::=, directly executable statement>>, <<with list element ::=, with list element>>

|_<<query expression body ::=, query expression body>>_
|<<query expression ::=, query expression>>, <<query primary ::=, query primary>>

|_<<query primary ::=, query primary>>_
|<<query term ::=, query term>>

|_<<querystring function ::=, querystring function>>_
|<<function ::=, function>>

|_<<query term ::=, query term>>_
|<<query expression body ::=, query expression body>>

|_<<raise statement ::=, raise statement>>_
|<<delimited statement ::=, delimited statement>>

|_<<like regex predicate ::=, like regex predicate>>_
|<<boolean primary ::=, boolean primary>>

|_<<return statement ::=, return statement>>_
|<<delimited statement ::=, delimited statement>>

|_<<searched case expression ::=, searched case expression>>_
|<<unsigned value expression primary ::=, unsigned value expression primary>>

|_<<select clause ::=, select clause>>_
|<<query ::=, query>>

|_<<select derived column ::=, select derived column>>_
|<<select sublist ::=, select sublist>>

|_<<select sublist ::=, select sublist>>_
|<<select clause ::=, select clause>>

|_<<set clause list ::=, set clause list>>_
|<<dynamic data statement ::=, dynamic data statement>>, <<update statement ::=, update statement>>

|_<<in predicate ::=, in predicate>>_
|<<boolean primary ::=, boolean primary>>

|_<<sort key ::=, sort key>>_
|<<sort specification ::=, sort specification>>

|_<<sort specification ::=, sort specification>>_
|<<order by clause ::=, order by clause>>

|_<<data statement ::=, data statement>>_
|<<delimited statement ::=, delimited statement>>

|_<<statement ::=, statement>>_
|<<alter ::=, alter>>, <<compound statement ::=, compound statement>>, <<create procedure ::=, create procedure>>, <<for each row trigger action ::=, for each row trigger action>>, <<if statement ::=, if statement>>, <<loop statement ::=, loop statement>>, <<procedure body definition ::=, procedure body definition>>, <<while statement ::=, while statement>>

|_<<call statement ::=, call statement>>_
|<<assignment statement ::=, assignment statement>>, <<subquery ::=, subquery>>, <<table subquery ::=, table subquery>>, <<directly executable statement ::=, directly executable statement>>

|_<<string ::=, string>>_
|<<character ::=, character>>, <<table element ::=, table element>>, <<option namespace ::=, option namespace>>, <<function ::=, function>>, <<xml namespace element ::=, xml namespace element>>, <<non numeric literal ::=, non numeric literal>>, <<object table column ::=, object table column>>, <<object table ::=, object table>>, <<procedure parameter ::=, procedure parameter>>, <<text table column ::=, text table column>>, <<text table ::=, text table>>, <<xml table column ::=, xml table column>>, <<xml query ::=, xml query>>, <<xml query ::=, xml query>>, <<xml serialize ::=, xml serialize>>, <<xml table ::=, xml table>>

|_<<subquery ::=, subquery>>_
|<<exists predicate ::=, exists predicate>>, <<in predicate ::=, in predicate>>, <<quantified comparison predicate ::=, quantified comparison predicate>>, <<unsigned value expression primary ::=, unsigned value expression primary>>

|_<<quantified comparison predicate ::=, quantified comparison predicate>>_
|<<boolean primary ::=, boolean primary>>

|_<<table subquery ::=, table subquery>>_
|<<table primary ::=, table primary>>

|_<<temporary table element ::=, temporary table element>>_
|<<create temporary table ::=, create temporary table>>

|_<<table primary ::=, table primary>>_
|<<cross join ::=, cross join>>, <<joined table ::=, joined table>>

|_<<table reference ::=, table reference>>_
|<<from clause ::=, from clause>>, <<qualified table ::=, qualified table>>

|_<<text aggreate function ::=, text aggreate function>>_
|<<unescapedFunction ::=, unescapedFunction>>

|_<<text table column ::=, text table column>>_
|<<text table ::=, text table>>

|_<<text table ::=, text table>>_
|<<table primary ::=, table primary>>

|_<<term ::=, term>>_
|<<numeric value expression ::=, numeric value expression>>

|_<<star or slash ::=, star or slash>>_
|<<term ::=, term>>

|_<<table name ::=, table name>>_
|<<table primary ::=, table primary>>

|_<<unescapedFunction ::=, unescapedFunction>>_
|<<unsigned value expression primary ::=, unsigned value expression primary>>

|_<<unsigned numeric literal ::=, unsigned numeric literal>>_
|<<option pair ::=, option pair>>, <<value expression primary ::=, value expression primary>>

|_<<unsigned value expression primary ::=, unsigned value expression primary>>_
|<<integer parameter ::=, integer parameter>>, <<value expression primary ::=, value expression primary>>

|_<<update statement ::=, update statement>>_
|<<assignment statement operand ::=, assignment statement operand>>, <<directly executable statement ::=, directly executable statement>>

|_<<directly executable statement ::=, directly executable statement>>_
|<<data statement ::=, data statement>>

|_<<value expression primary ::=, value expression primary>>_
|<<array table ::=, array table>>, <<term ::=, term>>

|_<<where clause ::=, where clause>>_
|<<delete statement ::=, delete statement>>, <<query ::=, query>>, <<update statement ::=, update statement>>

|_<<while statement ::=, while statement>>_
|<<statement ::=, statement>>

|_<<window specification ::=, window specification>>_
|<<unescapedFunction ::=, unescapedFunction>>

|_<<with list element ::=, with list element>>_
|<<query expression ::=, query expression>>

|_<<xml attributes ::=, xml attributes>>_
|<<xml element ::=, xml element>>

|_<<xml table column ::=, xml table column>>_
|<<xml table ::=, xml table>>

|_<<xml element ::=, xml element>>_
|<<function ::=, function>>

|_<<xml query ::=, xml query>>_
|<<boolean primary ::=, boolean primary>>

|_<<xml forest ::=, xml forest>>_
|<<function ::=, function>>

|_<<xml namespaces ::=, xml namespaces>>_
|<<xml element ::=, xml element>>, <<xml query ::=, xml query>>, <<xml forest ::=, xml forest>>, <<xml query ::=, xml query>>, <<xml table ::=, xml table>>

|_<<xml parse ::=, xml parse>>_
|<<function ::=, function>>

|_<<xml query ::=, xml query>>_
|<<function ::=, function>>

|_<<xml serialize ::=, xml serialize>>_
|<<function ::=, function>>

|_<<xml table ::=, xml table>>_
|<<table primary ::=, table primary>>
|===

== Productions

=== string ::=

* <string literal>

A string literal value. Use "to escape" in the string.

Example:

[source,sql]
----
'a string'
----

[source,sql]
----
'it"s a string'
----

=== reserved identifier ::=

* INSTEAD
* VIEW
* ENABLED
* DISABLED
* KEY
* SERIAL
* TEXTAGG
* COUNT
* ROW_NUMBER
* RANK
* DENSE_RANK
* SUM
* AVG
* MIN
* MAX
* EVERY
* STDDEV_POP
* STDDEV_SAMP
* VAR_SAMP
* VAR_POP
* DOCUMENT
* CONTENT
* TRIM
* EMPTY
* ORDINALITY
* PATH
* FIRST
* LAST
* NEXT
* SUBSTRING
* EXTRACT
* TO_CHARS
* TO_BYTES
* TIMESTAMPADD
* TIMESTAMPDIFF
* QUERYSTRING
* NAMESPACE
* RESULT
* INDEX
* ACCESSPATTERN
* AUTO_INCREMENT
* WELLFORMED
* SQL_TSI_FRAC_SECOND
* SQL_TSI_SECOND
* SQL_TSI_MINUTE
* SQL_TSI_HOUR
* SQL_TSI_DAY
* SQL_TSI_WEEK
* SQL_TSI_MONTH
* SQL_TSI_QUARTER
* SQL_TSI_YEAR
* TEXTTABLE
* ARRAYTABLE
* SELECTOR
* SKIP
* WIDTH
* PASSING
* NAME
* ENCODING
* COLUMNS
* DELIMITER
* QUOTE
* HEADER
* NULLS
* OBJECTTABLE
* VERSION
* INCLUDING
* EXCLUDING
* XMLDECLARATION
* VARIADIC
* RAISE
* EXCEPTION
* CHAIN
* JSONARRAY_AGG
* JSONOBJECT
* PRESERVE

Allows non-reserved keywords to be parsed as identifiers

Example:

[source,sql]
----
SELECT *COUNT* FROM …
----

=== identifier ::=

* <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenID[identifier]>
* <<<non-reserved identifier ::=, non-reserved identifier>>>

Partial or full name of a single entity.

Example:

[source,sql]
----
tbl.col
----

[source,sql]
----
"tbl"."col"
----

=== create trigger ::=

* link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenCREATE[CREATE] link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenTRIGGER[TRIGGER] link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenON[ON]
<<<identifier ::=, identifier>>> link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenINSTEAD[INSTEAD] link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenOF[OF] (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenINSERT[INSERT] | link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenUPDATE[UPDATE] | link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenDELETE[DELETE]) link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenAS[AS] <<<for each row trigger action ::=, for each row trigger action>>>

Creates a trigger action on the given target.

Example:

[source,sql]
----
CREATE TRIGGER ON vw INSTEAD OF INSERT AS FOR EACH ROW BEGIN ATOMIC ... END
----

=== alter ::=

* link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenALTER[ALTER] ( ( link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenVIEW[VIEW] <<<identifier ::=, identifier>>> link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenAS[AS] <<<query expression ::=, query expression>>> ) | ( link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenPROCEDURE[PROCEDURE] <<<identifier ::=, identifier>>> link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenAS[AS] <<<statement ::=, statement>>> ) | ( link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenTRIGGER[TRIGGER] link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenON[ON] <<<identifier ::=, identifier>>> link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenINSTEAD[INSTEAD] link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenOF[OF] ( link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenINSERT[INSERT] | link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenUPDATE[UPDATE] | link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenDELETE[DELETE] ) ( ( link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenAS[AS] <<<for each row trigger action ::=, for each row trigger action>>> ) | link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenENABLED[ENABLED] | link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenDISABLED[DISABLED]) ) )

Alter the given target.

Example:

[source,sql]
----
ALTER VIEW vw AS SELECT col FROM tbl
----

=== for each row trigger action ::=

* link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenFOR[FOR] link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenEACH[EACH] link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenROW[ROW] ((link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenBEGIN[BEGIN](link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenATOMIC[ATOMIC])? (<<<statement ::=, statement>>>)* link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenEND[END]) | <<<statement ::=, statement>>> )

Defines an action to perform on each row.

Example:

[source,sql]
----
FOR EACH ROW BEGIN ATOMIC ... END
----

=== directly executable statement ::=

* <<<query expression ::=, query expression>>>
* <<<call statement ::=, call statement>>>
* <<<insert statement ::=, insert statement>>>
* <<<update statement ::=, update statement>>>
* <<<delete statement ::=, delete statement>>>
* <<<drop table ::=, drop table>>>
* <<<create temporary table ::=, create temporary table>>>
* <<<create foreign temp table ::=, create foreign temp table>>>
* <<<alter ::=, alter>>>
* <<<create trigger ::=, create trigger>>>
* <<<compound statement ::=, compound statement>>>

A statement that can be executed at runtime.

Example:

[source,sql]
----
SELECT * FROM tbl
----

=== drop table ::=

* link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenDROP[DROP] link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenTABLE[TABLE] <<<identifier ::=, identifier>>>

Creates a trigger action on the given target.

Example:

[source,sql]
----
CREATE TRIGGER ON vw INSTEAD OF INSERT AS FOR EACH ROW BEGIN ATOMIC ... END
----

=== create temporary table ::=

*
link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenCREATE[CREATE](link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenLOCAL[LOCAL] )? link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenTEMPORARY[TEMPORARY] link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenTABLE[TABLE] <<<identifier ::=, identifier>>> <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenLPAREN[lparen]> <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar tableElement[temporary table element]> ( <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenCOMMA[comma]> <<<temporary table element ::=, temporary table element>>> )* ( <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenCOMMA[comma]> link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenPRIMARY[PRIMARY] link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenKEY[KEY] <<<column list ::=, column list>>> )? <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenRPAREN[rparen]> ( link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenON[ON] link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenCOMMIT[COMMIT] link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenPRESERVE[PRESERVE] link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenROWS[ROWS])?

Creates a temporary table.

Example:

[source,sql]
----
CREATE LOCAL TEMPORARY TABLE tmp (col integer)
----

=== temporary table element ::=

* <<<identifier ::=, identifier>>> (<<<data type ::=, data type>>> | link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenSERIAL[SERIAL]) (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenNOT[NOT] link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenNULL[NULL])?

Defines a temporary table column.

Example:

[source,sql]
----
col string NOT NULL
----

=== raise error statement ::=

* link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenERROR[ERROR] <<<expression ::=, expression>>>

Raises an error with the given message.

Example:

[source,sql]
----
ERROR 'something went wrong'
----

=== raise statement ::=

* link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenRAISE[RAISE] (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenSQLWARNING[SQLWARNING])? <<<exception reference ::=, exception reference>>>

Raises an error or warning with the given message.

Example:

[source,sql]
----
RAISE SQLEXCEPTION 'something went wrong'
----

=== exception reference ::=

* <<<identifier ::=, identifier>>>
* <<<sql exception ::=, sql exception>>>

a reference to an exception

Example:

[source,sql]
----
SQLEXCEPTION 'something went wrong' SQLSTATE '00X', 2
----

=== sql exception ::=

* link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenSQLEXCEPTION[SQLEXCEPTION] <<<common value expression ::=, common value expression>>> (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenSQLSTATE[SQLSTATE] <<<common value expression ::=, common value expression>>> (<link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenCOMMA[comma]> <<<common value expression ::=, common value expression>>> )? )? (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenCHAIN[CHAIN] <<<exception reference ::=, exception reference>>> )?

creates a sql exception or warning with the specified message, state, and code

Example:

[source,sql]
----
SQLEXCEPTION 'something went wrong' SQLSTATE '00X', 2
----

=== statement ::=

* ( (<<<identifier ::=, identifier>>> <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenCOLON[colon]> )? ( <<<loop statement ::=, loop statement>>> | <<<while statement ::=, while statement>>> | <<<compound statement ::=, compound statement>>> ) )
* <<<if statement ::=, if statement>>> | <<<delimited statement ::=, delimited statement>>>

A procedure statement.

Example:

[source,sql]
----
IF (x = 5) BEGIN ... END
----

=== delimited statement ::=

* (<<<assignment statement ::=, assignment statement>>> | <<<data statement ::=, data statement>>> | <<<raise error statement ::=, raise error statement>>> | <<<raise statement ::=, raise statement>>> | <<<declare statement ::=, declare statement>>> | <<<branching statement ::=, branching statement>>> | <<<return statement ::=, return statement>>> ) <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenSEMICOLON[semicolon]>

A procedure statement terminated by ;.

Example:

[source,sql]
----
SELECT * FROM tbl;
----

=== compound statement ::=

* link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenBEGIN[BEGIN] ((link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenNOT[NOT] )? link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenATOMIC[ATOMIC])? (<<<statement ::=, statement>>>)* (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenEXCEPTION[EXCEPTION] <<<identifier ::=, identifier>>> (<<<statement ::=, statement>>>)* )? link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenEND[END]

A procedure statement block contained in BEGIN END.

Example:

[source,sql]
----
BEGIN NOT ATOMIC ... END
----

=== branching statement ::=

* ( (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenBREAK[BREAK] | link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenCONTINUE[CONTINUE]) (<<<identifier ::=, identifier>>>)? )
* (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenLEAVE[LEAVE] <<<identifier ::=, identifier>>>)

A procedure branching control statement, which typically specifies a label to return control to.

Example:

[source,sql]
----
BREAK x
----

=== return statement ::=

* link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenRETURN[RETURN] (<<<expression ::=, expression>>>)?

A return statement.

Example:

[source,sql]
----
RETURN 1
----

=== while statement ::=

* link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenWHILE[WHILE] <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenLPAREN[lparen]> <<<condition ::=, condition>>> <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenRPAREN[rparen]> <<<statement ::=, statement>>>

A procedure while statement that executes until its condition is false.

Example:

[source,sql]
----
WHILE (var) BEGIN ... END
----

=== loop statement ::=

* link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenLOOP[LOOP] link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenON[ON] <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenLPAREN[lparen]> <<<query expression ::=, query expression>>> <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenRPAREN[rparen]> link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenAS[AS] <<<identifier ::=, identifier>>> <<<statement ::=, statement>>>

A procedure loop statement that executes over the given cursor.

Example:

[source,sql]
----
LOOP ON (SELECT * FROM tbl) AS x BEGIN ... END
----

=== if statement ::=

* link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenIF[IF] <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenLPAREN[lparen]> ( (<<<identifier ::=, identifier>>> link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenIS[IS] (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenNOT[NOT] )? link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenDISTINCT[DISTINCT] link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenFROM[FROM] <<<identifier ::=, identifier>>> ) | <<<condition ::=, condition>>> ) <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenRPAREN[rparen]> <<<statement ::=, statement>>> (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenELSE[ELSE] <<<statement ::=, statement>>>)?

A procedure loop statement that executes over the given cursor.

Example:

[source,sql]
----
IF (boolVal) BEGIN variables.x = 1 END ELSE BEGIN variables.x = 2 END
----

=== declare statement ::=

* link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenDECLARE[DECLARE] (<<<data type ::=, data type>>> | link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenEXCEPTION[EXCEPTION]) <<<identifier ::=, identifier>>> ( <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenEQ[eq]> <<<assignment statement operand ::=, assignment statement operand>>> )?

A procedure declaration statement that creates a variable and optionally assigns a value.

Example:

[source,sql]
----
DECLARE STRING x = 'a'
----

=== assignment statement ::=

* <<<identifier ::=, identifier>>> <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenEQ[eq]> (<<<assignment statement operand ::=, assignment statement operand>>> | (<<<call statement ::=, call statement>>> ( (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenWITH[WITH] | link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenWITHOUT[WITHOUT]) link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenRETURN[RETURN])? ) )

Assigns a variable a value in a procedure.

Example:

[source,sql]
----
x = 'b'
----

=== assignment statement operand ::=

* <<<insert statement ::=, insert statement>>>
* <<<update statement ::=, update statement>>>
* <<<delete statement ::=, delete statement>>>
* <<<expression ::=, expression>>>
* <<<query expression ::=, query expression>>>
* <<<sql exception ::=, sql exception>>>

A value or command that can be used in an assignment.

NOTE: All assigments except for expression are deprecated.

=== data statement ::=

* (<<<directly executable statement ::=, directly executable statement>>> | <<<dynamic data statement ::=, dynamic data statement>>> ) ( (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenWITH[WITH] | link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenWITHOUT[WITHOUT]) link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenRETURN[RETURN])?

A procedure statement that executes a SQL statement. An update statement can have its update count accessed via the ROWCOUNT variable.

=== procedure body definition ::=

* (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenCREATE[CREATE] (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenVIRTUAL[VIRTUAL])?link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenPROCEDURE[PROCEDURE])? <<<statement ::=, statement>>>

Defines a procedure body on a Procedure metadata object.

Example:

[source,sql]
----
BEGIN ... END
----

[[]]
dynamic data statement ::=
^^^^^^^^^^^^^^^^^^^^^^^^^^

* (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenEXECUTE[EXECUTE] | link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenEXEC[EXEC]) (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenSTRING[STRING] | link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenIMMEDIATE[IMMEDIATE])? <<<expression ::=, expression>>> ( link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenAS[AS] <<<typed element list ::=, typed element list>>> (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenINTO[INTO] <<<identifier ::=, identifier>>> )? )? (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenUSING[USING] <<<set clause list ::=, set clause list>>> )? (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenUPDATE[UPDATE] (<<<unsigned integer ::=, unsigned integer>>> | <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenSTAR[star]> ) )?

A procedure statement that can execute arbitrary sql.

Example:

[source,sql]
----
EXECUTE IMMEDIATE 'SELECT * FROM tbl' AS x STRING INTO #temp
----

=== set clause list ::=

* <<<identifier ::=, identifier>>> <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenEQ[eq]> <<<expression ::=, expression>>> (<link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenCOMMA[comma]> <<<identifier ::=, identifier>>> <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenEQ[eq]> <<<expression ::=, expression>>>)*

A list of value assignments.

Example:

[source,sql]
----
col1 = 'x', col2 = 'y' ...
----

=== typed element list ::=

* <<<identifier ::=, identifier>>> <<<data type ::=, data type>>> (<link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenCOMMA[comma]> <<<identifier ::=, identifier>>> <<<data type ::=, data type>>> )*

A list of typed elements.

Example:

[source,sql]
----
col1 string, col2 integer ...
----

=== callable statement ::=

* <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenLBRACE[lbrace]> (<link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenQMARK[qmark]> <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenEQ[eq]> )? link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenCALL[CALL] <<<identifier ::=, identifier>>> (<link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar tokenLPAREN[lparen]> (<<<named parameter list ::=, named parameter list>>> | (<<<expression list ::=, expression list>>> )? ) <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenRPAREN[rparen]> )? <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenRBRACE[rbrace]> ( <<<option clause ::=, option clause>>> )?

A callable statement defined using JDBC escape syntax.

Example:

[source,sql]
----
{? = CALL proc}
----

=== call statement ::=

* ( (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenEXEC[EXEC] | link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenEXECUTE[EXECUTE] | link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenCALL[CALL]) <<<identifier ::=, identifier>>> <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenLPAREN[lparen]> (<<<named parameter list ::=, named parameter list>>> | (<<<expression list ::=, expression list>>> )? ) <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenRPAREN[rparen]> ) ( <<<option clause ::=, option clause>>> )?

Executes the procedure with the given parameters.

Example:

[source,sql]
----
CALL proc('a', 1)
----

=== named parameter list ::=

* (<<<identifier ::=, identifier>>> <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenEQ[eq]> (<link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenGT[gt]> )? <<<expression ::=, expression>>> (<link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenCOMMA[comma]> <<<identifier ::=, identifier>>> <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenEQ[eq]> (<link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenGT[gt]> )? <<<expression ::=, expression>>>)* )

A list of named parameters.

Example:

[source,sql]
----
param1 => 'x', param2 => 1
----

=== insert statement ::=

* (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenINSERT[INSERT] | link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenMERGE[MERGE]) link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenINTO[INTO] <<<identifier ::=, identifier>>> (<<<column list ::=, column list>>> )? <<<query expression ::=, query expression>>> (<<<option clause ::=, option clause>>> )?

Inserts values into the given target.

Example:

[source,sql]
----
INSERT INTO tbl (col1, col2) VALUES ('a', 1)
----

=== expression list ::=

* <<<expression ::=, expression>>> (<link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenCOMMA[comma]> <<<expression ::=, expression>>>)*

A list of expressions.

Example:

[source,sql]
----
col1, 'a', ...
----

=== update statement ::=

* link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenUPDATE[UPDATE] <<<identifier ::=, identifier>>> link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenSET[SET] <<<set clause list ::=, set clause list>>> ( <<<where clause ::=, where clause>>> )? ( <<<option clause ::=, option clause>>> )?

Update values in the given target.

Example:

[source,sql]
----
UPDATE tbl SET (col1 = 'a') WHERE col2 = 1
----

=== delete statement ::=

* link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenDELETE[DELETE] link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenFROM[FROM] <<<identifier ::=, identifier>>> ( <<<where clause ::=, where clause>>> )? (<<<option clause ::=, option clause>>> )?

Delete rows from the given target.

Example:

[source,sql]
----
DELETE FROM tbl WHERE col2 = 1
----

=== query expression ::=

* (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenWITH[WITH] <<<with list element ::=, with list element>>> (<link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenCOMMA[comma]> <<<with list element ::=, with list element>>> )* )? <<<query expression body ::=, query expression body>>>

A declarative query for data.

Example:

[source,sql]
----
SELECT * FROM tbl WHERE col2 = 1
----

=== with list element ::=

* <<<identifier ::=, identifier>>> (<<<column list ::=, column list>>> )? link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenAS[AS] <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenLPAREN[lparen]> <<<query expression ::=, query expression>>> <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenRPAREN[rparen]>

A query expression for use in the enclosing query.

Example:

[source,sql]
----
X (Y, Z) AS (SELECT 1, 2)
----

=== query expression body ::=

* <<<query term ::=, query term>>> ( (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenUNION[UNION] | link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenEXCEPT[EXCEPT]) (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenALL[ALL] | link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenDISTINCT[DISTINCT])? <<<query term ::=, query term>>> )* (<<<order by clause ::=, order by clause>>> )? (<<<limit clause ::=, limit clause>>> )? (<<<option clause ::=, option clause>>> )?

The body of a query expression, which can optionally be ordered and limited.

Example:

[source,sql]
----
SELECT * FROM tbl ORDER BY col1 LIMIT 1
----

=== query term ::=

* <<<query primary ::=, query primary>>> (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenINTERSECT[INTERSECT] (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenALL[ALL] | link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenDISTINCT[DISTINCT])?<<<query primary ::=, query primary>>> )*

Used to establish INTERSECT precedence.

Example:

[source,sql]
----
SELECT * FROM tbl
----

[source,sql]
----
SELECT * FROM tbl1 INTERSECT SELECT * FROM tbl2
----

=== query primary ::=

* <<<query ::=, query>>>
* (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenVALUES[VALUES] <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenLPAREN[lparen]> <<<expression list ::=, expression list>>> <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenRPAREN[rparen]> (<link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenCOMMA[comma]> <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenLPAREN[lparen]> <<<expression list ::=, expression list>>> <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenRPAREN[rparen]>)* )
* (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenTABLE[TABLE] <<<identifier ::=, identifier>>>)
* (<link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenLPAREN[lparen]> <<<query expression body ::=, query expression body>>> <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenRPAREN[rparen]>)

A declarative source of rows.

Example:

[source,sql]
----
TABLE tbl
----

[source,sql]
----
SELECT * FROM tbl1
----

=== query ::=

* <<<select clause ::=, select clause>>> (<<<into clause ::=, into clause>>> )? (<<<from clause ::=, from clause>>> (<<<where clause ::=, where clause>>> )? (<<<group by clause ::=, group by clause>>> )? (<<<having clause ::=, having clause>>> )? )?

A SELECT query.

Example:

[source,sql]
----
SELECT col1, max(col2) FROM tbl GROUP BY col1
----

=== into clause ::=

* link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenINTO[INTO] <<<identifier ::=, identifier>>>

Used to direct the query into a table.

NOTE: This is deprecated. Use INSERT INTO with a query expression instead.

Example:

[source,sql]
----
INTO tbl
----

=== select clause ::=

* link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenSELECT[SELECT] ( link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenALL[ALL] | link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenDISTINCT[DISTINCT])? (<link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenSTAR[star]> | (<<<select sublist ::=, select sublist>>> (<link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenCOMMA[comma]> <<<select sublist ::=, select sublist>>> )* ) )

The columns returned by a query. Can optionally be distinct.

Example:

[source,sql]
----
SELECT *
----

[source,sql]
----
SELECT DISTINCT a, b, c
----

=== select sublist ::=

* <<<select derived column ::=, select derived column>>>
* <<<all in group ::=, all in group>>>

An element in the select clause

Example:

[source,sql]
----
tbl.*
----

[source,sql]
----
tbl.col AS x
----

=== select derived column ::=

* (<<<expression ::=, expression>>> ( ( link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenAS[AS])? <<<identifier ::=, identifier>>>)? )

A select clause item that selects a single column.

NOTE: This is slightly different than a derived column in that the AS keyword is optional.

Example:

[source,sql]
----
tbl.col AS x
----

=== derived column ::=

* (<<<expression ::=, expression>>> ( link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenAS[AS] <<<identifier ::=, identifier>>>)? )

An optionally named expression.

Example:

[source,sql]
----
tbl.col AS x
----

=== all in group ::=

* <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenALLINGROUP[all in group identifier]>

A select sublist that can select all columns from the given group.

Example:

[source,sql]
----
tbl.*
----

=== ordered aggreate function ::=

* (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenXMLAGG[XMLAGG] | link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenARRAYAGG[ARRAY_AGG] | link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenJSONARRAYAGG[JSONARRAY_AGG]) <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenLPAREN[lparen]> <<<expression ::=, expression>>> (<<<order by clause ::=, order by clause>>> )? <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenRPAREN[rparen]>

An aggregate function that can optionally be ordered.

Example:

[source,sql]
----
XMLAGG(col1) ORDER BY col2
----

[source,sql]
----
ARRAY_AGG(col1)
----

=== text aggreate function ::=

* link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenTEXTAGG[TEXTAGG] <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenLPAREN[lparen]> ( link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenFOR[FOR])? <<<derived column ::=, derived column>>> (<link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenCOMMA[comma]> <<<derived column ::=, derived column>>> )* (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenDELIMITER[DELIMITER] <<<character ::=, character>>>)? (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenQUOTE[QUOTE] <<<character ::=, character>>>)? (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenHEADER[HEADER])? (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenENCODING[ENCODING] <<<identifier ::=, identifier>>>)? (<<<order by clause ::=, order by clause>>> )? <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenRPAREN[rparen]>

An aggregate function for creating separated value clobs.

Example:

[source,sql]
----
TEXTAGG (col1 as t1, col2 as t2 DELIMITER ',' HEADER)
----

=== standard aggregate function ::=

* ( link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenCOUNT[COUNT] <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenLPAREN[lparen]> <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenSTAR[star]> <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenRPAREN[rparen]>)
* ( (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenCOUNT[COUNT] | link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenSUM[SUM] | link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenAVG[AVG] | link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenMIN[MIN] | link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenMAX[MAX] | link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenEVERY[EVERY] | link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenSTDDEVPOP[STDDEV_POP] | link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenSTDDEVSAMP[STDDEV_SAMP] | link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenVARSAMP[VAR_SAMP] | link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenVARPOP[VAR_POP] | link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenSOME[SOME] | link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenANY[ANY]) <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenLPAREN[lparen]> (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenDISTINCT[DISTINCT] | link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenALL[ALL])?<<<expression ::=, expression>>> <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenRPAREN[rparen]>)

A standard aggregate function.

Example:

[source,sql]
----
COUNT(*)
----

=== analytic aggregate function ::=

* (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenROWNUMBER[ROW_NUMBER] | link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenRANK[RANK] |
link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenDENSERANK[DENSE_RANK] ) <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenLPAREN[lparen]> <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenRPAREN[rparen]>

An analytic aggregate function.

Example:

[source,sql]
----
ROW_NUMBER()
----

=== filter clause ::=

* link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenFILTER[FILTER] <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenLPAREN[lparen]> link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenWHERE[WHERE] <<<boolean primary ::=, boolean primary>>> <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenRPAREN[rparen]>

An aggregate filter clause applied prior to accumulating the value.

Example:

[source,sql]
----
FILTER (WHERE col1='a')
----

=== from clause ::=

* link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenFROM[FROM] (<<<table reference ::=, table reference>>> (<link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenCOMMA[comma]> <<<table reference ::=, table reference>>> )* )

A query from clause containing a list of table references.

Example:

[source,sql]
----
FROM a, b
----
[source,sql]
----
FROM a right outer join b, c, d join e".</p>
----

=== table reference ::=

* (<link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenESCAPEDJOIN[escaped join]> <<<joined table ::=, joined table>>> <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenRBRACE[rbrace]> )
* <<<joined table ::=, joined table>>>

An optionally escaped joined table.

Example:

[source,sql]
----
a
----

[source,sql]
----
a inner join b
----

=== joined table ::=

* <<<table primary ::=, table primary>>> (<<<cross join ::=, cross join>>> | <<<qualified table ::=, qualified table>>> )*

A table or join.

Example:

[source,sql]
----
a
----

[source,sql]
----
a inner join b
----

=== cross join ::=

* ( (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenCROSS[CROSS] | link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenUNION[UNION]) link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenJOIN[JOIN] <<<table primary ::=, table primary>>> )

A cross join.

Example:

[source,sql]
----
a CROSS JOIN b
----

=== qualified table ::=

* ( ( (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenRIGHT[RIGHT] (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenOUTER[OUTER])? ) | (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenLEFT[LEFT] (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenOUTER[OUTER])? ) | (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenFULL[FULL] (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenOUTER[OUTER])? ) | link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenINNER[INNER])? link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenJOIN[JOIN] <<<table reference ::=, table reference>>> link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenON[ON] <<<condition ::=, condition>>>)

An INNER or OUTER join.

Example:

[source,sql]
----
a inner join b
----

=== table primary ::=

* (<<<text table ::=, text table>>> | <<<array table ::=, array table>>> | <<<xml table ::=, xml table>>> | <<<object table ::=, object table>>> | <<<table name ::=, table name>>> | <<<table subquery ::=, table subquery>>> | (<link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenLPAREN[lparen]> <<<joined table ::=, joined table>>> <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenRPAREN[rparen]>) ) ( (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenMAKEDEP[MAKEDEP] <<<make dep options ::=, make dep options>>> ) | link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenMAKENOTDEP[MAKENOTDEP])? ( (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenMAKEIND[MAKEIND] <<<make dep options ::=, make dep options>>> ) )?

A single source of rows.

Example:

[source,sql]
----
a
----

=== make dep options ::=

* (<link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenLPAREN[lparen]> ( link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenMAX[MAX] <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenCOLON[colon]> <<<unsigned integer ::=, unsigned integer>>> )? ( (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenNO[NO] )? link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenJOIN[JOIN])? <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenRPAREN[rparen]>)?

options for the make dep hint

Example:

[source,sql]
----
(min:10000)
----

=== xml serialize ::=

* link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenXMLSERIALIZE[XMLSERIALIZE] <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenLPAREN[lparen]> (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenDOCUMENT[DOCUMENT] | link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenCONTENT[CONTENT])? <<<expression ::=, expression>>> ( link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenAS[AS] (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenSTRING[STRING] | link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenVARCHAR[VARCHAR] | link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenCLOB[CLOB] | link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenVARBINARY[VARBINARY] | link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenBLOB[BLOB]) )? (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenENCODING[ENCODING] <<<identifier ::=, identifier>>>)? (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenVERSION[VERSION] <<<string ::=, string>>>)? ( (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenINCLUDING[INCLUDING] | link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenEXCLUDING[EXCLUDING]) link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenXMLDECLARATION[XMLDECLARATION])? <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenRPAREN[rparen]>

Serializes an XML value.

Example:

[source,sql]
----
XMLSERIALIZE(col1 AS CLOB)
----

=== array table ::=

* link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenARRAYTABLE[ARRAYTABLE] <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenLPAREN[lparen]> <<<value expression primary ::=, value expression primary>>> link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenCOLUMNS[COLUMNS] <<<typed element list ::=, typed element list>>> <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenRPAREN[rparen]> ( link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenAS[AS] )? <<<identifier ::=, identifier>>>

The ARRAYTABLE table function creates tabular results from arrays. It can be used as a nested table reference.

Example:

[source,sql]
----
ARRAYTABLE (col1 COLUMNS x STRING) AS y
----

=== text table ::=

* link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenTEXTTABLE[TEXTTABLE] <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenLPAREN[lparen]> <<<common value expression ::=, common value expression>>> (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenSELECTOR[SELECTOR] <<<string ::=, string>>>)? link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenCOLUMNS[COLUMNS] <<<text table column ::=, text table column>>> (<link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenCOMMA[comma]> <<<text table column ::=, text table column>>> )* ( (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenNO[NO] link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenROW[ROW] link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenDELIMITER[DELIMITER]) | (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenROW[ROW] link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenDELIMITER[DELIMITER] <<<character ::=, character>>>) )? (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenDELIMITER[DELIMITER] <<<character ::=, character>>>)? ( (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenESCAPE[ESCAPE] <<<character ::=, character>>>) | (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenQUOTE[QUOTE] <<<character ::=, character>>>) )? (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenHEADER[HEADER] (<<<unsigned integer ::=, unsigned integer>>> )? )? (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenSKIPKEYWORD[SKIP] <<<unsigned integer ::=, unsigned integer>>> )? (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenNO[NO] link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenTRIM[TRIM])? <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenRPAREN[rparen]> ( link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenAS[AS] )? <<<identifier ::=, identifier>>>

The TEXTTABLE table function creates tabular results from text. It can be used as a nested table reference.

Example:

[source,sql]
----
TEXTTABLE (file COLUMNS x STRING) AS y
----

=== text table column ::=

* <<<identifier ::=, identifier>>> ( (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenFOR[FOR] link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenORDINALITY[ORDINALITY]) | ( (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenHEADER[HEADER] <<<string ::=, string>>>)? <<<data type ::=, data type>>> (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenWIDTH[WIDTH] <<<unsigned integer ::=, unsigned integer>>> (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenNO[NO] link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenTRIM[TRIM])? )? (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenSELECTOR[SELECTOR] <<<string ::=, string>>> <<<unsigned integer ::=, unsigned integer>>> )? ) )

A text table column.

Example:

[source,sql]
----
x INTEGER WIDTH 6
----

=== xml query ::=

* link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenXMLEXISTS[XMLEXISTS] <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenLPAREN[lparen]> (<<<xml namespaces ::=, xml namespaces>>> <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenCOMMA[comma]>)? <<<string ::=, string>>> (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenPASSING[PASSING] <<<derived column ::=, derived column>>> (<link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenCOMMA[comma]> <<<derived column ::=, derived column>>> )* )? <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenRPAREN[rparen]>

Executes an XQuery to return an XML result.

Example:

[source,sql]
----
XMLQUERY('<a>...</a>' PASSING doc)
----

=== xml query ::=

* link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenXMLQUERY[XMLQUERY] <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenLPAREN[lparen]> (<<<xml namespaces ::=, xml namespaces>>> <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenCOMMA[comma]>)? <<<string ::=, string>>> (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenPASSING[PASSING] <<<derived column ::=, derived column>>> (<link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenCOMMA[comma]> <<<derived column ::=, derived column>>> )* )? ( (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenNULL[NULL] | link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenEMPTY[EMPTY]) link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenON[ON] link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenEMPTY[EMPTY])? <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenRPAREN[rparen]>

Executes an XQuery to return an XML result.

Example:

[source,sql]
----
XMLQUERY('<a>...</a>' PASSING doc)
----

=== object table ::=

* link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenOBJECTTABLE[OBJECTTABLE] <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenLPAREN[lparen]> (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenLANGUAGE[LANGUAGE] <<<string ::=, string>>>)? <<<string ::=, string>>> (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenPASSING[PASSING] <<<derived column ::=, derived column>>> (<link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenCOMMA[comma]> <<<derived column ::=, derived column>>> )* )? link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenCOLUMNS[COLUMNS] <<<object table column ::=, object table column>>> (<link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenCOMMA[comma]> <<<object table column ::=, object table column>>> )* <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenRPAREN[rparen]>( link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenAS[AS] )? <<<identifier ::=, identifier>>>

Returns table results by processing a script.

Example:

[source,sql]
----
OBJECTTABLE('z' PASSING val AS z COLUMNS col OBJECT 'teiid_row') AS X
----

=== object table column ::=

* <<<identifier ::=, identifier>>> <<<data type ::=, data type>>> <<<string ::=, string>>> (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenDEFAULTKEYWORD[DEFAULT] <<<expression ::=, expression>>>)?

object table column.

Example:

[source,sql]
----
y integer 'teiid_row_number'
----

=== xml table ::=

* link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenXMLTABLE[XMLTABLE] <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenLPAREN[lparen]> (<<<xml namespaces ::=, xml namespaces>>> <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenCOMMA[comma]>)? <<<string ::=, string>>> (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenPASSING[PASSING] <<<derived column ::=, derived column>>> (<link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenCOMMA[comma]> <<<derived column ::=, derived column>>> )* )? (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenCOLUMNS[COLUMNS] <<<xml table column ::=, xml table column>>> (<link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenCOMMA[comma]> <<<xml table column ::=, xml table column>>> )* )? <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenRPAREN[rparen]>( link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenAS[AS] )? <<<identifier ::=, identifier>>>

Returns table results by processing an XQuery.

Example:

[source,sql]
----
XMLTABLE('/a/b' PASSING doc COLUMNS col XML PATH '.') AS X
----

=== xml table column ::=

* <<<identifier ::=, identifier>>> ( (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenFOR[FOR] link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenORDINALITY[ORDINALITY]) | (<<<data type ::=, data type>>> (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenDEFAULTKEYWORD[DEFAULT] <<<expression ::=, expression>>>)? (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenPATH[PATH] <<<string ::=, string>>>)? ) )

XML table column.

Example:

[source,sql]
----
y FOR ORDINALITY
----

=== unsigned integer ::=

* <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenUNSIGNEDINTEGER[unsigned integer literal]>

An unsigned interger value.

Example:

[source,sql]
----
12345
----

=== table subquery ::=

* (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenTABLE[TABLE] | link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenLATERAL[LATERAL])? <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenLPAREN[lparen]> (<<<query expression ::=, query expression>>> | <<<call statement ::=, call statement>>> ) <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenRPAREN[rparen]> ( link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenAS[AS] )? <<<identifier ::=, identifier>>>

A table defined by a subquery.

Example:

[source,sql]
----
(SELECT * FROM tbl) AS x
----

=== table name ::=

* (<<<identifier ::=, identifier>>> ( ( link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenAS[AS])? <<<identifier ::=, identifier>>>)? )

A table named in the FROM clause.

Example:

[source,sql]
----
tbl AS x
----

=== where clause ::=

* link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenWHERE[WHERE] <<<condition ::=, condition>>>

Specifies a search condition

Example:

[source,sql]
----
WHERE x = 'a'
----

=== condition ::=

* <<<boolean value expression ::=, boolean value expression>>>

A boolean expression.

=== boolean value expression ::=

* <<<between term ::=, between term>>> (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenOR[OR] <<<between term ::=, between term>>> )*

An optionally ORed boolean expression.

=== oolean term ::=

* <<<boolean factor ::=, boolean factor>>> ( link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenAND[AND] <<<boolean factor ::=, boolean factor>>> )*

An optional ANDed boolean factor.

=== boolean factor ::=

* (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenNOT[NOT] )? <<<boolean primary ::=, boolean primary>>>

A boolean factor.

Example:

[source,sql]
----
NOT x = 'a'
----

=== boolean primary ::=

* (<<<common value expression ::=, common value expression>>> (<<<between predicate ::=, between predicate>>> | <<<match predicate ::=, match predicate>>> | <<<like regex predicate ::=, like regex predicate>>> | <<<in predicate ::=, in predicate>>> | <<<is null predicate ::=, is null predicate>>> | <<<quantified comparison predicate ::=, quantified comparison predicate>>> | <<<comparison predicate ::=, comparison predicate>>> )? )
* <<<exists predicate ::=, exists predicate>>>
* <<<xml query ::=, xml query>>>

A boolean predicate or simple expression.

Example:

[source,sql]
----
col LIKE 'a%'
----

=== comparison operator ::=

* <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenEQ[eq]>
* <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenNE[ne]>
* <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenNE2[ne2]>
* <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenLT[lt]>
* <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenLE[le]>
* <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenGT[gt]>
* <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenGE[ge]>

A comparison operator.

Example:

[source,sql]
----
=
----

=== comparison predicate ::=

* <<<comparison operator ::=, comparison operator>>> <<<common value expression ::=, common value expression>>>

A value comparison.

Example:

[source,sql]
----
= 'a'
----

=== subquery ::=

* <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenLPAREN[lparen]> (<<<query expression ::=, query expression>>> | <<<call statement ::=, call statement>>> ) <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenRPAREN[rparen]>

A subquery.

Example:

[source,sql]
----
(SELECT * FROM tbl)
----

=== quantified comparison predicate ::=

* <<<comparison operator ::=, comparison operator>>> (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenANY[ANY] | link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenSOME[SOME] | link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenALL[ALL]) <<<subquery ::=, subquery>>>

A subquery comparison.

Example:

[source,sql]
----
= ANY (SELECT col FROM tbl)
----

=== match predicate ::=

* (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenNOT[NOT] )? (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenLIKE[LIKE] | (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenSIMILAR[SIMILAR] link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenTO[TO] ) ) <<<common value expression ::=, common value expression>>> (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenESCAPE[ESCAPE] <<<character ::=, character>>> | (<link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenLBRACE[lbrace]> link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenESCAPE[ESCAPE] <<<character ::=, character>>> <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenRBRACE[rbrace]>) )?

Matches based upon a pattern.

Example:

[source,sql]
----
LIKE 'a_'
----

=== like regex predicate ::=

* (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenNOT[NOT] )? link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenLIKEREGEX[LIKE_REGEX] <<<common value expression ::=, common value expression>>>

A regular expression match.

Example:

[source,sql]
----
LIKE_REGEX 'a.*b'
----

=== character ::=

* <<<string ::=, string>>>

A single character.

Example:

[source,sql]
----
'a'
----

=== between predicate ::=

* (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenNOT[NOT] )? link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenBETWEEN[BETWEEN] <<<common value expression ::=, common value expression>>> link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenAND[AND] <<<common value expression ::=, common value expression>>>

A comparison between two values.

Example:

[source,sql]
----
BETWEEN 1 AND 5
----

=== is null predicate ::=

* link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenIS[IS] (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenNOT[NOT] )? link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenNULL[NULL]

A null test.

Example:

[source,sql]
----
IS NOT NULL
----

=== in predicate ::=

* (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenNOT[NOT] )? link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenIN[IN] (<<<subquery ::=, subquery>>> | (<link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenLPAREN[lparen]> <<<common value expression ::=, common value expression>>> (<link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenCOMMA[comma]> <<<common value expression ::=, common value expression>>> )* <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenRPAREN[rparen]>) )

A comparison with multiple values.

Example:

[source,sql]
----
IN (1, 5)
----

=== exists predicate ::=

* link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenEXISTS[EXISTS] <<<subquery ::=, subquery>>>

A test if rows exist.

Example:

[source,sql]
----
EXISTS (SELECT col FROM tbl)
----

=== group by clause ::=

* link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenGROUP[GROUP] link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenBY[BY] (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenROLLUP[ROLLUP] <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenLPAREN[lparen]> <<<expression list ::=, expression list>>> <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenRPAREN[rparen]> | <<<expression list ::=, expression list>>> )

Defines the grouping columns

Example:

[source,sql]
----
GROUP BY col1, col2
----

=== having clause ::=

* link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenHAVING[HAVING] <<<condition ::=, condition>>>

Search condition applied after grouping.

Example:

[source,sql]
----
HAVING max(col1) = 5
----

=== order by clause ::=

* link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenORDER[ORDER] link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenBY[BY] <<<sort specification ::=, sort specification>>> (<link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenCOMMA[comma]> <<<sort specification ::=, sort specification>>> )*

Specifices row ordering.

Example:

[source,sql]
----
ORDER BY x, y DESC
----

=== sort specification ::=

* <<<sort key ::=, sort key>>> (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenASC[ASC] | link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenDESC[DESC])? (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenNULLS[NULLS] (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenFIRST[FIRST] | link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenLAST[LAST]) )?

Defines how to sort on a particular expression

Example:

[source,sql]
----
col1 NULLS FIRST
----

=== sort key ::=

* <<<expression ::=, expression>>>

A sort expression.

Example:

[source,sql]
----
col1
----

=== integer parameter ::=

* <<<unsigned integer ::=, unsigned integer>>>
* <<<unsigned value expression primary ::=, unsigned value expression primary>>>

A literal integer or parameter reference to an integer.

Example:

[source,sql]
----
?
----

=== limit clause ::=

* (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenLIMIT[LIMIT] <<<integer parameter ::=, integer parameter>>> (<link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenCOMMA[comma]> <<<integer parameter ::=, integer parameter>>> )? )
* (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenOFFSET[OFFSET] <<<integer parameter ::=, integer parameter>>> (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenROW[ROW] | link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenROWS[ROWS]) (<<<fetch clause ::=, fetch clause>>> )? )
* <<<fetch clause ::=, fetch clause>>>

Limits and/or offsets the resultant rows.

Example:

[source,sql]
----
LIMIT 2
----

=== fetch clause ::=

* link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenFETCH[FETCH] (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenFIRST[FIRST] | link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenNEXT[NEXT]) (<<<integer parameter ::=, integer parameter>>> )? (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenROW[ROW] | link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenROWS[ROWS]) link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenONLY[ONLY]

ANSI limit.

Example:

[source,sql]
----
FETCH FIRST 1 ROWS ONLY
----

=== option clause ::=

* link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenOPTION[OPTION] (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenMAKEDEP[MAKEDEP] <<<identifier ::=, identifier>>> <<<make dep options ::=, make dep options>>> (<link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenCOMMA[comma]> <<<identifier ::=, identifier>>> <<<make dep options ::=, make dep options>>> )* | link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenMAKEIND[MAKEIND] <<<identifier ::=, identifier>>> <<<make dep options ::=, make dep options>>> (<link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenCOMMA[comma]> <<<identifier ::=, identifier>>> <<<make dep options ::=, make dep options>>> )* | link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenMAKENOTDEP[MAKENOTDEP] <<<identifier ::=, identifier>>> (<link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenCOMMA[comma]> <<<identifier ::=, identifier>>>)* | link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenNOCACHE[NOCACHE] (<<<identifier ::=, identifier>>> (<link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenCOMMA[comma]> <<<identifier ::=, identifier>>>)* )? )*

Specifies query options.

Example:

[source,sql]
----
OPTION MAKEDEP tbl
----

=== expression ::=

* <<<condition ::=, condition>>>

A value.

Example:

[source,sql]
----
col1
----

=== common value expression ::=

* (<<<numeric value expression ::=, numeric value expression>>> (<link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenCONCATOP[concat_op]> <<<numeric value expression ::=, numeric value expression>>> )* )

Establishes the precedence of concat.

Example:

[source,sql]
----
'a' || 'b'
----

=== numeric value expression ::=

* (<<<term ::=, term>>> (<<<plus or minus ::=, plus or minus>>> <<<term ::=, term>>>)* )

Example:

[source,sql]
----
1 + 2
----

=== plus or minus ::=

* <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenPLUS[plus]>
* <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenMINUS[minus]>

The + or - operator.

Example:

[source,sql]
----
+
----

=== term ::=

* (<<<value expression primary ::=, value expression primary>>> (<<<star or slash ::=, star or slash>>> <<<value expression primary ::=, value expression primary>>> )* )

A numeric term

Example:

[source,sql]
----
1 * 2
----

=== star or slash ::=

* <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenSTAR[star]>
* <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenSLASH[slash]>

The * or / operator.

Example:

[source,sql]
----
/
----

=== value expression primary ::=

* <<<non numeric literal ::=, non numeric literal>>>
* (<<<plus or minus ::=, plus or minus>>> )? (<<<unsigned numeric literal ::=, unsigned numeric literal>>> | (<<<unsigned value expression primary ::=, unsigned value expression primary>>> (<link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenLSBRACE[lsbrace]> <<<numeric value expression ::=, numeric value expression>>> <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenRSBRACE[rsbrace]>)* ) )

A simple value expression.

Example:

[source,sql]
----
+col1
----

=== parameter reference ::=

* <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenQMARK[qmark]>
* ( <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenDOLLAR[dollar]> <<<unsigned integer ::=, unsigned integer>>> )

A parameter reference to be bound later.

Example:

[source,sql]
----
?
----

=== unescapedFunction ::=

* ( (<<<text aggreate function ::=, text aggreate function>>> | <<<standard aggregate function ::=, standard aggregate function>>> | <<<ordered aggreate function ::=, ordered aggreate function>>> ) (<<<filter clause ::=, filter clause>>> )? (<<<window specification ::=, window specification>>> )? ) | (<<<analytic aggregate function ::=, analytic aggregate function>>> (<<<filter clause ::=, filter clause>>> )? <<<window specification ::=, window specification>>> ) | (<<<function ::=, function>>> (<<<window specification ::=, window specification>>> )? )
* (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenXMLCAST[XMLCAST] <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenLPAREN[lparen]> <<<expression ::=, expression>>> link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenAS[AS] <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar parseDataType[data type]> <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenRPAREN[rparen]>)

=== nested expression ::=

* (<link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenLPAREN[lparen]> (<<<expression ::=, expression>>> (<link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenCOMMA[comma]> <<<expression ::=, expression>>>)* )? (<link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenCOMMA[comma]>) <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenRPAREN[rparen]>)

An expression nested in parens

Example:

[source,sql]
----
(1)
----

=== unsigned value expression primary ::=

* <<<parameter reference ::=, parameter reference>>>
* (<link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenESCAPEDFUNCTION[escaped function]> <<<function ::=, function>>> <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenRBRACE[rbrace]>)
* <<<unescapedFunction ::=, unescapedFunction>>>
* <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenID[identifier]> | <<<non-reserved identifier ::=, non-reserved identifier>>>
* <<<subquery ::=, subquery>>>
* <<<nested expression ::=, nested expression>>>
* <<<searched case expression ::=, searched case expression>>>
* <l<<case expression ::=, case expression>>>

An unsigned simple value expression.

Example:

[source,sql]
----
col1
----

=== window specification ::=

* link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenOVER[OVER] <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenLPAREN[lparen]> (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenPARTITION[PARTITION] link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenBY[BY] <<<expression list ::=, expression list>>> )? (<<<order by clause ::=, order by clause>>> )? <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenRPAREN[rparen]>

The window specification for an analytical or windowed aggregate function.

Example:

[source,sql]
----
OVER (PARTION BY col1)
----

=== case expression ::=

* link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenCASE[CASE] <<<expression ::=, expression>>> (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenWHEN[WHEN] <<<expression ::=, expression>>> link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenTHEN[THEN] <<<expression ::=, expression>>>)+ (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenELSE[ELSE] <<<expression ::=, expression>>>)? link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenEND[END]

If/then/else chain using a common search predicand.

Example:

[source,sql]
----
CASE col1 WHEN 'a' THEN 1 ELSE 2
----

=== searched case expression ::=

* link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenCASE[CASE] (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenWHEN[WHEN] <<<condition ::=, condition>>> link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenTHEN[THEN] <<<expression ::=, expression>>>)+ ( link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenELSE[ELSE] <<<expression ::=, expression>>>)? link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenEND[END]

If/then/else chain using multiple search conditions.

Example:

[source,sql]
----
CASE WHEN x = 'a' THEN 1 WHEN y = 'b' THEN 2
----

=== function ::=

* (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenCONVERT[CONVERT] <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenLPAREN[lparen]> <<<expression ::=, expression>>> <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenCOMMA[comma]> <<<data type ::=, data type>>> <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenRPAREN[rparen]>)
* (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenCAST[CAST] <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenLPAREN[lparen]> <<<expression ::=, expression>>> link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenAS[AS] <<<data type ::=, data type>>> <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenRPAREN[rparen]>)
* (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenSUBSTRING[SUBSTRING] <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenLPAREN[lparen]> <<<expression ::=, expression>>> ( (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenFROM[FROM] <<<expression ::=, expression>>> ( link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenFOR[FOR] <<<expression ::=, expression>>>)? ) | (<link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenCOMMA[comma]> <<<expression list ::=, expression list>>> ) ) <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenRPAREN[rparen]>)
* (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenEXTRACT[EXTRACT] <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenLPAREN[lparen]> (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenYEAR[YEAR] | link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenMONTH[MONTH] | link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenDAY[DAY] | link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenHOUR[HOUR] | link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenMINUTE[MINUTE] | link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenSECOND[SECOND]) link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenFROM[FROM] <<<expression ::=, expression>>> <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenRPAREN[rparen]>)
* (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenTRIM[TRIM] <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenLPAREN[lparen]> ( ( ( (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenLEADING[LEADING] | link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenTRAILING[TRAILING] | link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenBOTH[BOTH]) (<<<expression ::=, expression>>>)? ) | <<<expression ::=, expression>>>) link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenFROM[FROM])? <<<expression ::=, expression>>> <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenRPAREN[rparen]>)
* ( (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenTOCHARS[TO_CHARS] | link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenTOBYTES[TO_BYTES]) <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenLPAREN[lparen]> <<<expression ::=, expression>>> <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenCOMMA[comma]> <<<string ::=, string>>> (<link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenCOMMA[comma]> <<<expression ::=, expression>>>)? <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenRPAREN[rparen]>)
* ( (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenTIMESTAMPADD[TIMESTAMPADD] | link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenTIMESTAMPDIFF[TIMESTAMPDIFF]) <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenLPAREN[lparen]> <<<time interval ::=, time interval>>> <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenCOMMA[comma]> <<<expression ::=, expression>>> <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenCOMMA[comma]> <<<expression ::=, expression>>> <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenRPAREN[rparen]>)
* <<<querystring function ::=, querystring function>>>
* ( (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenLEFT[LEFT] | link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenRIGHT[RIGHT] | link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenCHAR[CHAR] | link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenUSER[USER] | link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenYEAR[YEAR] | link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenMONTH[MONTH] | link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenHOUR[HOUR] | link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenMINUTE[MINUTE] | link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenSECOND[SECOND] | link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenXMLCONCAT[XMLCONCAT] | link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenXMLCOMMENT[XMLCOMMENT] | link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenXMLTEXT[XMLTEXT]) <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenLPAREN[lparen]> (<<<expression list ::=, expression list>>> )?<link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenRPAREN[rparen]>)
* ( (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenTRANSLATE[TRANSLATE] | link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenINSERT[INSERT]) <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenLPAREN[lparen]> (<<<expression list ::=, expression list>>> )?<link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenRPAREN[rparen]>)
* <<<xml parse ::=, xml parse>>>
* <<<xml element ::=, xml element>>>
* (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenXMLPI[XMLPI] <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenLPAREN[lparen]> ( (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenNAME[NAME])? <<<identifier ::=, identifier>>>) (<link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenCOMMA[comma]> <<<expression ::=, expression>>>)? <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenRPAREN[rparen]>)
* <<<xml forest ::=, xml forest>>>
* <<<json object ::=, json object>>>
* <<<xml serialize ::=, xml serialize>>>
* <<<xml query ::=, xml query>>>
* (<<<identifier ::=, identifier>>> <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenLPAREN[lparen]> ( link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenALL[ALL] | link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenDISTINCT[DISTINCT] )? (<<<expression list ::=, expression list>>> )? (<<<order by clause ::=, order by clause>>> )?<link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenRPAREN[rparen]> (<<<filter clause ::=, filter clause>>> )? )

Calls a scalar function.

Example:

[source,sql]
----
func('1', col1)
----

=== xml parse ::=

* link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenXMLPARSE[XMLPARSE] <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenLPAREN[lparen]> (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenDOCUMENT[DOCUMENT] | link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenCONTENT[CONTENT]) <<<expression ::=, expression>>> (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenWELLFORMED[WELLFORMED])?<link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenRPAREN[rparen]>

Parses the given value as XML.

Example:

[source,sql]
----
XMLPARSE(DOCUMENT doc WELLFORMED)
----

=== querystring function ::=

* link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenQUERYSTRING[QUERYSTRING] <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenLPAREN[lparen]> <<<expression ::=, expression>>> (<link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenCOMMA[comma]> <<<derived column ::=, derived column>>> )* <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenRPAREN[rparen]>

Produces a URL query string from the given arguments.

Example:

[source,sql]
----
QUERYSTRING('path', col1 AS opt, col2 AS val)
----

=== xml element ::=

* link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenXMLELEMENT[XMLELEMENT] <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenLPAREN[lparen]> ( (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenNAME[NAME])? <<<identifier ::=, identifier>>>) (<link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenCOMMA[comma]> <<<xml namespaces ::=, xml namespaces>>> )? (<link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenCOMMA[comma]> <<<xml attributes ::=, xml attributes>>> )? (<link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenCOMMA[comma]> <<<expression ::=, expression>>>)* <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenRPAREN[rparen]>

Creates an XML element.

Example:

[source,sql]
----
XMLELEMENT(NAME "root", child)
----

=== xml attributes ::=

* link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenXMLATTRIBUTES[XMLATTRIBUTES] <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenLPAREN[lparen]> <<<derived column ::=, derived column>>> (<link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenCOMMA[comma]> <<<derived column ::=, derived column>>> )* <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenRPAREN[rparen]>

Creates attributes for the containing element.

Example:

[source,sql]
----
XMLATTRIBUTES(col1 AS attr1, col2 AS attr2)
----

=== json object ::=

* link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenJSONOBJECT[JSONOBJECT] <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenLPAREN[lparen]> <<<derived column list ::=, derived column list>>> <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenRPAREN[rparen]>

Produces a JSON object containing name value pairs.

Example:

[source,sql]
----
JSONOBJECT(col1 AS val1, col2 AS val2)
----

=== derived column list ::=

* <<<derived column ::=, derived column>>> (<link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenCOMMA[comma]> <<<derived column ::=, derived column>>> )*

a list of name value pairs

Example:

[source,sql]
----
col1 AS val1, col2 AS val2
----

=== xml forest ::=

* link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenXMLFOREST[XMLFOREST] <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenLPAREN[lparen]>
(<<<xml namespaces ::=, xml namespaces>>> <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenCOMMA[comma]>)? <<<derived column list ::=, derived column list>>> <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenRPAREN[rparen]>

Produces an element for each derived column.

Example:

[source,sql]
----
XMLFOREST(col1 AS ELEM1, col2 AS ELEM2)
----

=== xml namespaces ::=

* link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenXMLNAMESPACES[XMLNAMESPACES] <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenLPAREN[lparen]> <<<xml namespace element ::=, xml namespace element>>> (<link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenCOMMA[comma]> <<<xml namespace element ::=, xml namespace element>>> )* <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenRPAREN[rparen]>

Defines XML namespace URI/prefix combinations

Example:

[source,sql]
----
XMLNAMESPACES('http://foo' AS foo)
----

=== xml namespace element ::=

* ( <<<string ::=, string>>> link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenAS[AS] <<<identifier ::=, identifier>>>)
* ( link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenNO[NO] link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenDEFAULTKEYWORD[DEFAULT])
* (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenDEFAULTKEYWORD[DEFAULT] <<<string ::=, string>>> )

An xml namespace

Example:

[source,sql]
----
NO DEFAULT
----

=== simple data type ::=

* (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenSTRING[STRING] (<link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenLPAREN[lparen]> <<<unsigned integer ::=, unsigned integer>>> <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenRPAREN[rparen]>)? )
* (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenVARCHAR[VARCHAR] (<link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenLPAREN[lparen]> <<<unsigned integer ::=, unsigned integer>>> <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenRPAREN[rparen]>)? )
* link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenBOOLEAN[BOOLEAN]
* link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenBYTE[BYTE]
* link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenTINYINT[TINYINT]
* link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenSHORT[SHORT]
* link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenSMALLINT[SMALLINT]
* (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenCHAR[CHAR] (<link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenLPAREN[lparen]> <<<unsigned integer ::=, unsigned integer>>> <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenRPAREN[rparen]>)? )
* link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenINTEGER[INTEGER]
* link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenLONG[LONG]
* link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenBIGINT[BIGINT]
* ( link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenBIGINTEGER[BIGINTEGER] (<link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenLPAREN[lparen]> <<<unsigned integer ::=, unsigned integer>>> <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenRPAREN[rparen]>)? )
* link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenFLOAT[FLOAT]
* link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenREAL[REAL]
* link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenDOUBLE[DOUBLE]
* (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenBIGDECIMAL[BIGDECIMAL] (<link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenLPAREN[lparen]> <<<unsigned integer ::=, unsigned integer>>> (<link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenCOMMA[comma]> <<<unsigned integer ::=, unsigned integer>>> )? <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenRPAREN[rparen]>)? )
* (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenDECIMAL[DECIMAL] (<link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenLPAREN[lparen]> <<<unsigned integer ::=, unsigned integer>>> (<link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenCOMMA[comma]> <<<unsigned integer ::=, unsigned integer>>> )? <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenRPAREN[rparen]>)? )
* link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenDATE[DATE]
* link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenTIME[TIME]
* link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenTIMESTAMP[TIMESTAMP]
* (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenOBJECT[OBJECT] (<link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenLPAREN[lparen]> <<<unsigned integer ::=, unsigned integer>>> <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenRPAREN[rparen]>)? )
* ( link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenBLOB[BLOB] (<link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenLPAREN[lparen]> <<<unsigned integer ::=, unsigned integer>>> <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenRPAREN[rparen]>)? )
* (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenCLOB[CLOB] (<link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenLPAREN[lparen]> <<<unsigned integer ::=, unsigned integer>>> <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenRPAREN[rparen]>)? )
* (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenVARBINARY[VARBINARY] (<link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenLPAREN[lparen]> <<<unsigned integer ::=, unsigned integer>>> <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenRPAREN[rparen]>)? )
* link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenGEOMETRY[GEOMETRY]
* link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenXML[XML]

A non-collection data type.

Example:

[source,sql]
----
STRING
----

=== data type ::=

* <<<simple data type ::=, simple data type>>> (<link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenLSBRACE[lsbrace]> <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenRSBRACE[rsbrace]>)*

A data type.

Example:

[source,sql]
----
STRING[]
----

=== time interval ::=

* link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenSQLTSIFRACSECOND[SQL_TSI_FRAC_SECOND]
* link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenSQLTSISECOND[SQL_TSI_SECOND]
* link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenSQLTSIMINUTE[SQL_TSI_MINUTE]
* link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenSQLTSIHOUR[SQL_TSI_HOUR]
* link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenSQLTSIDAY[SQL_TSI_DAY]
* link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenSQLTSIWEEK[SQL_TSI_WEEK]
* link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenSQLTSIMONTH[SQL_TSI_MONTH]
* link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenSQLTSIQUARTER[SQL_TSI_QUARTER]
* link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenSQLTSIYEAR[SQL_TSI_YEAR]

A time interval keyword.

Example:

[source,sql]
----
SQL_TSI_HOUR
----

=== non numeric literal ::=

* <<<string ::=, string>>>
* <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenBINARYSTRINGVAL[binary string literal]>
* link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenFALSE[FALSE]
* link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenTRUE[TRUE]
* link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenUNKNOWN[UNKNOWN]
* link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenNULL[NULL]
* (<link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenESCAPEDTYPE[escaped type]> <<<string ::=, string>>> <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenRBRACE[rbrace]>)
* ( (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenDATE[DATE] | link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenTIME[TIME] | link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenTIMESTAMP[TIMESTAMP]) <<<string ::=, string>>>)

An escaped or simple non numeric literal.

Example:

[source,sql]
----
'a'
----

=== unsigned numeric literal ::=

* <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenUNSIGNEDINTEGER[unsigned integer literal]>
* <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenFLOATVAL[approximate numeric literal]>
* <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenDECIMALVAL[decimal numeric literal]>

An unsigned numeric literal value.

Example:

[source,sql]
----
1.234
----

=== ddl statement ::=

* (<<<create table ::=, create table>>> | <<<create procedure ::=, create procedure>>> | <<<option namespace ::=, option namespace>>> | <<<alter options ::=, alter options>>> | <<<create trigger ::=, create trigger>>> ) (<link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenSEMICOLON[semicolon]>)?

A data definition statement.

Example:

[source,sql]
----
CREATE FOREIGN TABLE X (Y STRING)
----

=== option namespace ::=

* link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenSET[SET] link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenNAMESPACE[NAMESPACE] <<<string ::=, string>>> link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenAS[AS] <<<identifier ::=, identifier>>>

A namespace used to shorten the full name of an option key.

Example:

[source,sql]
----
SET NAMESPACE 'http://foo' AS foo
----

=== create procedure ::=

* link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenCREATE[CREATE] (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenVIRTUAL[VIRTUAL] | link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenFOREIGN[FOREIGN])? (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenPROCEDURE[PROCEDURE] | link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenFUNCTION[FUNCTION]) (<<<identifier ::=, identifier>>> <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenLPAREN[lparen]> (<<<procedure parameter ::=, procedure parameter>>> (<link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenCOMMA[comma]> <<<procedure parameter ::=, procedure parameter>>> )* )? <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenRPAREN[rparen]> (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenRETURNS[RETURNS] (<<<options clause ::=, options clause>>> )? ( ( (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenTABLE[TABLE])? <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenLPAREN[lparen]> <<<procedure result column ::=, procedure result column>>> (<link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenCOMMA[comma]> <<<procedure result column ::=, procedure result column>>> )* <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenRPAREN[rparen]>) | <<<data type ::=, data type>>> ) )? (<<<options clause ::=, options clause>>> )? (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenAS[AS] <<<statement ::=, statement>>>)? )

Defines a procedure or function invocation.

Example:

[source,sql]
----
CREATE FOREIGN PROCEDURE proc (param STRING) RETURNS STRING
----

=== procedure parameter ::=

* ( link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenIN[IN] | link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenOUT[OUT] | link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenINOUT[INOUT] | link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenVARIADIC[VARIADIC])? <<<identifier ::=, identifier>>> <<<data type ::=, data type>>> (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenNOT[NOT] link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenNULL[NULL])? (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenRESULT[RESULT])? ( link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenDEFAULTKEYWORD[DEFAULT] <<<string ::=, string>>>)? (<<<options clause ::=, options clause>>> )?

A procedure or function parameter

Example:

[source,sql]
----
OUT x INTEGER
----

=== procedure result column ::=

* <<<identifier ::=, identifier>>> <<<data type ::=, data type>>> (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenNOT[NOT] link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenNULL[NULL])? (<<<options clause ::=, options clause>>> )?

A procedure result column.

Example:

[source,sql]
----
x INTEGER
----

=== create table ::=

* link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenCREATE[CREATE] ( (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenFOREIGN[FOREIGN] link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenTABLE[TABLE]) | ( (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenVIRTUAL[VIRTUAL])? link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenVIEW[VIEW]) | (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenGLOBAL[GLOBAL] link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenTEMPORARY[TEMPORARY] link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenTABLE[TABLE]) ) <<<identifier ::=, identifier>>> (<<<create table body ::=, create table body>>> | (<<<options clause ::=, options clause>>> )? ) (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenAS[AS] <<<query expression ::=, query expression>>> )?

Defines a table or view.

Example:

[source,sql]
----
CREATE VIEW vw AS SELECT 1
----

=== create foreign temp table ::=

* link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenCREATE[CREATE] (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenLOCAL[LOCAL])? link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenFOREIGN[FOREIGN] link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenTEMPORARY[TEMPORARY] link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenTABLE[TABLE] <<<identifier ::=, identifier>>> <<<create table body ::=, create table body>>> link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenON[ON] <<<identifier ::=, identifier>>>

Defines a foreign temp table

Example:

[source,sql]
----
CREATE FOREIGN TEMPORARY TABLE t (x string) ON z
----

=== create table body ::=

* <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenLPAREN[lparen]> <<<table element ::=, table element>>> ( <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenCOMMA[comma]> <<<table element ::=, table element>>> )* (<link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenCOMMA[comma]> (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenCONSTRAINT[CONSTRAINT] <<<identifier ::=, identifier>>>)? (<<<primary key ::=, primary key>>> | <<<other constraints ::=, other constraints>>> | <<<foreign key ::=, foreign key>>> ) (<<<options clause ::=, options clause>>> )? )* <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenRPAREN[rparen]> (<<<options clause ::=, options clause>>> )?

Defines a table.

Example:

[source,sql]
----
(x string) OPTIONS (CARDINALITY 100)
----

=== foreign key ::=

* link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenFOREIGN[FOREIGN] link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenKEY[KEY] <<<column list ::=, column list>>> link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenREFERENCES[REFERENCES] <<<identifier ::=, identifier>>> (<<<column list ::=, column list>>> )?

Defines the foreign key referential constraint.

Example:

[source,sql]
----
FOREIGN KEY (a, b) REFERENCES tbl (x, y)
----

=== primary key ::=

* link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenPRIMARY[PRIMARY] link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenKEY[KEY] <<<column list ::=, column list>>>

Defines the primary key.

Example:

[source,sql]
----
PRIMARY KEY (a, b)
----

=== other constraints ::=

* ( (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenUNIQUE[UNIQUE] | link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenACCESSPATTERN[ACCESSPATTERN]) <<<column list ::=, column list>>> )
* (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenINDEX[INDEX] <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenLPAREN[lparen]> <<<expression list ::=, expression list>>> <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenRPAREN[rparen]>)

Defines ACCESSPATTERN and UNIQUE constraints and INDEXes.

Example:

[source,sql]
----
UNIQUE (a)
----

=== column list ::=

* <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenLPAREN[lparen]> <<<identifier ::=, identifier>>> (<link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenCOMMA[comma]> <<<identifier ::=, identifier>>>)* <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenRPAREN[rparen]>

A list of column names.

Example:

[source,sql]
----
(a, b)
----

=== table element ::=

* <<<identifier ::=, identifier>>> (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenSERIAL[SERIAL] | (<<<data type ::=, data type>>> (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenNOT[NOT] link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenNULL[NULL])? (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenAUTOINCREMENT[AUTO_INCREMENT])? ) ) ( (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenPRIMARY[PRIMARY] link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenKEY[KEY] ) | ( (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenUNIQUE[UNIQUE])? (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenINDEX[INDEX])? ) ) (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenDEFAULTKEYWORD[DEFAULT] <<<string ::=, string>>>)? (<<<options clause ::=, options clause>>> )?

Defines a table column.

Example:

[source,sql]
----
x INTEGER NOT NULL
----

=== options clause ::=

* link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenOPTIONS[OPTIONS] <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenLPAREN[lparen]> <<<option pair ::=, option pair>>> (<link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenCOMMA[comma]> <<<option pair ::=, option pair>>> )* <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenRPAREN[rparen]>

A list of statement options.

Example:

[source,sql]
----
OPTIONS ('x' 'y', 'a' 'b')
----

=== option pair ::=

* <<<identifier ::=, identifier>>> (<<<non numeric literal ::=, non numeric literal>>> | (<<<plus or minus ::=, plus or minus>>> )?<<<unsigned numeric literal ::=, unsigned numeric literal>>> )

An option key/value pair.

Example:

[source,sql]
----
'key' 'value'
----

=== alter options ::=

* link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenALTER[ALTER] (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenVIRTUAL[VIRTUAL] | link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenFOREIGN[FOREIGN])? (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenTABLE[TABLE] | link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenVIEW[VIEW] | link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenPROCEDURE[PROCEDURE]) <<<identifier ::=, identifier>>> (<<<alter options list ::=, alter options list>>> | <<<alter column options ::=, alter column options>>> )

alters options of tables/procedure

Example:

[source,sql]
----
ALTER FOREIGN TABLE foo OPTIONS (ADD cardinality 100)
----

=== alter options list ::=

* link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenOPTIONS[OPTIONS] <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenLPAREN[lparen]> (<<<add set option ::=, add set option>>> | <<<drop option ::=, drop option>>> ) (<link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenCOMMA[comma]> (<<<add set option ::=, add set option>>> | <<<drop option ::=, drop option>>> ) )* <link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenRPAREN[rparen]>

a list of alterations to options

Example:

[source,sql]
----
OPTIONS (ADD updatable true)
----

=== drop option ::=

* link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenDROP[DROP] <<<identifier ::=, identifier>>>

drop option

Example:

[source,sql]
----
DROP updatable
----

=== add set option ::=

* (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenADD[ADD] | link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenSET[SET] ) <<<option pair ::=, option pair>>>

add or set an option pair

Example:

[source,sql]
----
ADD updatable true
----

=== alter column options ::=

* link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenALTER[ALTER] (link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenCOLUMN[COLUMN] | link:BNF_for_SQL_Grammar.adoc#18646304_BNFforSQLGrammar-tokenPARAMETER[PARAMETER])? <<<identifier ::=, identifier>>> <<<alter options list ::=, alter options list>>>

alters a set of column options

Example:

[source,sql]
----
ALTER COLUMN bar OPTIONS (ADD updatable true)
----


